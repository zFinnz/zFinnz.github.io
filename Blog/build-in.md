| Stt | Hàm | Mô tả |
|-----|-----|-----| 
| 1 | [abs()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-0)	| Trả về giá trị tuyệt đối của một số	|
| 2 | [all()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-1)	| Trả về True khi tất cả các phần tử trong iterable là đúng |
| 3 | [any()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-2)	| Kiểm tra bất kỳ phần tử nào của iterable là True |
| 4 | [ascii()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-3) | Tả về string chứa đại diện (representation) có thể in |
| 5 | [bin()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-4)	| Chuyển đổi số nguyên sang chuỗi nhị phân |
| 6 | [bool()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-5) | Chuyển một giá trị sang Boolean |
| 7 | [breakpoint()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-6) | Đưa bạn vào trình gỡ lỗi nơi được gọi |
| 8 | [bytearray()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-7) | Trả về mảng kích thước byte được cấp |
| 9 | [bytes()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-8) | Trả về đối tượng byte không đổi |
| 10 | [callable()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-9) | Kiểm tra xem đối tượng có thể gọi hay không |
| 11 | [chr()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-10)	| Trả về một ký tự (một chuỗi) từ Integer |
| 12 | [classmethod()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-11)	| Trả về một class method cho hàm |
| 13 | [compile()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-12)	| Trả về đối tượng code Python |
| 14 | [complex()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-13)	| Tạo một số phức |
| 15 | [delattr()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-14)	| Xóa thuộc tính khỏi đối tượng |
| 16 | [dict()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-15) | Tạo Dictionary |
| 17 | [dir()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-16)	| Trả lại thuộc tính của đối tượng |
| 18 | [divmod()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-17)	| Trả về một Tuple của Quotient và Remainder |
| 19 | [enumerate()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-18) | Trả về đối tượng kê khai |
| 20 | [eval()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-19) | Chạy code Python trong chương trình |
| 21 | [exec()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-20) | Thực thi chương trình được tạo động |
| 22 | [filter()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-21) | Xây dựng iterator từ các phần tử True |
| 23 | [float()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-22) | Trả về số thập phân từ số, chuỗi |
| 24 | [format()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-23) | Trả về representation được định dạng của giá trị |
| 25 | [frozenset()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-24) | Trả về đối tượng frozenset không thay đổi |
| 26 | [getattr()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-25) | Trả về giá trị thuộc tính được đặt tên của đối tượng |
| 27 | [globals()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-26)	| Trả về dictionary của bảng sumbol toàn cục hiện tại |
| 27 | [hasattr()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-27)	| Trả về đối tượng dù có thuộc tính được đặt tên hay không |
| 29 | [hash()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-28) | Trả về giá trị hash của đối tượng |
| 30 | [help()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-29) | Gọi Help System được tích hợp sẵn |
| 31 | [hex()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-30)	| Chuyển Integer thành Hexadecimal |
| 32 | [id()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-31) | Trả về định danh của đối tượng |
| 33 | [input()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-32) | Đọc và trả về chuỗi trong một dòng |
| 34 | [int()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-33)	| Trả về số nguyên từ số hoặc chuỗi |
| 35 | [isinstance()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-34) | Kiểm tra xem đối tượng có là Instance của Class không |
| 36 | [issubclass()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-35) | Kiểm tra xem đối tượng có là Subclass của Class không |
| 37 | [iter()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-36) | Trả về iterator cho đối tượng |
| 38| [len()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-37)	| Trả về độ dài của đối tượng |
| 39 | [list()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-38) | Tạo list trong Python |
| 40 | [locals()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-39)| Trả về dictionary của bảng sumbol cục bộ hiện tại |
| 41 | [map()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-40)	| Áp dụng hàm và trả về một list |
| 42 | [max()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-41)	| Trả về phần tử lớn nhất |
| 43 | [memoryview()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-42) | Trả về chế độ xem bộ nhớ của đối số |
| 44 | [min()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-43)	| Trả về phần tử nhỏ nhất |
| 45 | [next()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-44) | Trích xuất phần tử tiếp theo từ Iterator |
| 46 | [object()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-45) | Tạo một đối tượng không có tính năng (Featureless Object) | |
| 47 | [oct()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-46)	| Chuyển số nguyên sang bát phân |
| 48 | [open()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-47) | Trả về đối tượng File |
| 49 | [ord()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-48)	| Trả về mã Unicode code cho ký tự Unicode |
| 50 | [pow()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-49)	| Trả về x mũ y |
| 51 | [print()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-50) | In đối tượng được cung cấp |
| 52 | [property()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-51) | Trả về thuộc tính property |
| 53 | [range()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-52) | Trả về chuỗi số nguyên từ số bắt đầu đến số kết thúc |
| 54 | [repr()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-53) | Trả về representation có thể in của đối tượng |
| 55 | [reversed()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-54) | Trả về iterator đảo ngược của một dãy |
| 56 | [round()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-55) | Làm tròn số thập phân |
| 57 | [set()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-56)	| Tạo một set các phần tử mới |
| 58 | [setattr()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-57)	| Đặt giá trị cho một thuộc tính của đối tượng |
| 59 | [slice()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-58) | Cắt đối tượng được chỉ định bằng range() |
| 60 | [sorted()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-59) | Trả về list được sắp xếp |
| 61 | [staticmethod()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-60) | Tạo static method từ một hàm |
| 62 | [str()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-61)	| Trả về một representation không chính thức của một đối tượng |
| 63 | [sum()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-62)	| Thêm một mục vào Iterable |
| 64 | [super()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-63) | Cho phép tham chiếu đến Parent Class bằng super |
| 65 | [tuple()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-64) | Tạo một Tuple |
| 66 | [type()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-65) | Trả về kiểu đối tượng |
| 67 | [vars()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-66) | Trả về thuộc tính __dict__ của class |
| 68 | [zip()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-67)	| Trả về Iterator của Tuple |
| 69 | [__import__()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-68) | Hàm nâng cao, được gọi bằng import |


#### abs(num)
Hàm trả về giá trị tuyệt đối của một số đã cho (`num`) tùy theo kiểu giá trị của `num`:
+ `integer`: giá trị tuyệt `num` được trả về
+ `float`: giá trị tuyệt đối `num` được trả về
+ `complex`: độ lớn của `num` được trả về
```py
# số integer bất kì
>>> integer = -20
>>> abs(integer)
20
# số float bất kì
>>> floating = -30.33
>>> abs(floating)
30.33
# số complex bất kì
>>> complex = (3 - 4j)
>>> abs(complex)
5.0
```

#### any(iterable)
Kiểm tra và trả về `True` nếu bất kì phần tử nào của `iterable` (`list`, `string`, `dictionary`...) là `True`, ngược lại trả về `False` nếu tất cả các phần tử là sai hoặc có một `interable` rỗng.
Hàm `any()` có thể viết tương đương như sau:
```py
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
```
Ví dụ:
```py
# any() với kiểu list
>>> l = [1, 3, 4, 0]
>>> print(any(l))
True
>>> l = [0, False]
>>> print(any(l))
False
# any() với kiểu string
>>> s = "This is good"
>>> print(any(s))
True
>>> s = ''
>>> print(any(s))
False
# any() với kiểu dictionary
>>> d = {0: 'False'}
>>> print(any(d))
False
>>> d = {0: 'False', 1: 'True'}
>>> print(any(d))
True
```
#### all(terable)
Kiểm tra và trả về `True` nếu tất cả phần tử của `Iterable` là `true`, ngược lại là `False` nếu có bất kì phần tử nào của `interable` là `false`.
Hàm `any()` có thể viết tương đương như sau:
```py
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
```
Ví dụ:
```py
# all() với kiểu list
>>> l = [1, 3, 4, 5]
>>> print(all(l))
True
>>> l = [0, False]
>>> print(all(l))
False
# all() với kiểu string
>>> s = ['hello','World']
>>> all(s)
True
>>> s = ['', 'hello']
>>> all(s)
False
# all() với kiểu dictionary
>>> s = {0: 'False', 1: 'False'}
>>> print(all(s))
False
>>> s = {1: 'True', 2: 'True'}
>>> print(all(s))
True
```
#### ascii(object)
Trả về chuỗi `string` có thể in ra màn hình (`printable`) của object. Nó bỏ qua các ký tự không phải ASCII trong chuỗi bằng cách sử dụng kí tự thoát `\x`, `\u` hoặc `\U`. Hàm chỉ nhận một tham số là đối tượng (như `string`, `list`,...).
Ví dụ, ö sẽ được chuyển thành \xf6, √ sẽ thành \u221a, Šsẽ thành \u0152.
```py
>>> s = "Hello \n World"
>>> ascii(s)
'Hello \\n World'
>>> randomList = ['Python','PŸTHON','√', 'ö','Pythön', 'Š', 'Œ','Ž',10, '©']
>>> print(ascii(randomList))
['Python', 'P\u0178THON', '\u221a', '\xf6', 'Pyth\xf6n', '\u0160', '\u0152', '\u017d', 10, '\xa9']
```
#### bin(num)
Hàm chuyển đổi và trả về một chuỗi nhị phân bắt đầu bằng `0b` của một số nguyên. Hàm `bin()` chỉ có 1 tham số là `num`, nếu `num` không phải là số nguyên, nó phải thực thi một phương thức `__index__()` để trả về một số nguyên. Nếu `num` không được hiểu là số nguyên thì việc chạy hàm sẽ tạo ra một ngoại lệ `TypeError`.
```py
>>> bin(3)
'0b11'
>>> bin(-10)
'-0b1010'
# nếu không muốn có tiền tố 0b bạn có thể sử dụng:
>>> format(14, '#b'), format(14, 'b')
('0b1110', '1110')
>>> f'{14:#b}', f'{14:b}'
('0b1110', '1110')
```
Chuyển đổi 1 đối tượng `object` sang `binary` sử dụng phương thức `__index__()`:
```py
class Quantity:
    apple = 1
    orange = 2
    grapes = 2
    
    def __index__(self):
        return self.apple + self.orange + self.grapes
        
bin(Quantity())
0b101
```
#### bool([value])
Chuyển đổi chuỗi sang giá trị `Boolean`. `Value` được chuyển đổi bằng [Truth Value Testing](https://docs.python.org/3/library/stdtypes.html#truth).
Nếu `value` là `false` hoặc bị bỏ qua, nó sẽ trả về `False`; nếu không nó sẽ trả về `True`. Các lớp  `bool` là một lớp con của `int`. Nó không thể được phân lớp thêm. Các trường hợp duy nhất của nó là `False` và `True`.
Các giá trị sau được coi là `False` trong Python:
+ None
+ False
+ Không thuộc bất kỳ loại số nào. Ví dụ, `0`, `0.0`,`0j`
+ Chuỗi rỗng. Ví dụ:  `()`, `[]`, `''`.
+ Mapping trống. Ví dụ: `{}`
+ đối tượng của các lớp có phương thức `__bool__()` hoặc `__len()__` trả về `0` hoặc `False`
Tất cả các giá trị nằm ngoài danh sách trên được coi là `True`.
```py
>>> bool("hello")
True
>>> bool('')
False
>>> bool(None)
False
>>> bool([0])
True
```

#### breakpoint( `*args` , `**kws` )
Hàm này sẽ đưa bạn vào trình gỡ rối tại trang được gọi (nó sẽ gọi `sys.breakpointhook()`), thực hiện với 2 biến `*args`, `**kws`. Theo mặc định `sys.breakpointhook()` gọi `pdb.set_trace()`. Trong trường hợp này, đây một chức năng tiện lợi, thay thì bạn phải `import pdb` hay viết nhiều mã để nhập vào trình gỡ lỗi hàm này sẽ làm giúp bạn.
```py
>>> name = "value"
>>> breakpoint()
# --Return--
# > <stdin>(1)<module>()->None
# (Pdb) >
```


#### bytearray([source[, encoding[, errors]]])
Hàm trả về một đối tượng `bytearray` là một mảng của các `byte` cho trước và là một chuỗi các số nguyên có thể thay đổi (có thể được sửa đổi) trong phạm vi `0 <= x <256`. Trong đó:
+ `source`: nguồn để khởi tạo mảng `byte`.
+ `encoding`:  Tham số chuyển đổi giải mã chuỗi, xem các tùy chọn ở dưới.
+ `errors`: nếu nguồn là một chuỗi, `errors` cũng cấp hành động cần thực hiện khi chuyển đổi mã hóa không thành công.
Các tham số nguồn khác nhau:
+ `String`: nếu nguồn là một chuỗi, phải cung cấp `encoding` và các `errors` tùy chọn của chuỗi sau đó chuyển đổi chuỗi thành byte bằng cách sử dụng `str.encode()`.
+ `integer`: Tạo một mảng có kích thước được cung cấp, tất cả được khởi tạo thành `null`.
+ `Object`:  Bộ đệm chỉ đọc của đối tượng sẽ được sử dụng để khởi tạo mảng `byte`.
+ `iterable`: Tạo một mảng có kích thước bằng số lần lặp và được khởi tạo thành các phần tử của `iterable` Các số nguyên phải nằm trong khoảng `0 <= x <256`.
+ `Không có tham số`: Tạo một mảng có kích thước `0`.
Nếu bạn muốn làm việc với số nguyên không thể thay đổi xem thêm [bytes()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-8)
```py
# Đối với source là string
>>> string = "0xpan.blogspot.com."
>>> arr = bytearray(string, 'utf-8')
>>> print(arr)
bytearray(b'0xpan.blogspot.com.')
# Đối với source là int
>>> size = 5
>>> arr = bytearray(size)
>>> print(arr)
bytearray(b'\x00\x00\x00\x00\x00')
# Đối với source là iterable list
>>> rList = [1, 2, 3, 4, 5]
>>> arr = bytearray(rList)
>>> print(arr)
bytearray(b'\x01\x02\x03\x04\x05')
```

#### bytes([source[, encoding[, errors]]])
Hàm `bytes()` trả về một đối tượng `byte` mới là một chuỗi các số nguyên `immmutable` (không thể sửa đổi) trong phạm vi `0 <= x <256` được khởi tạo với kích thước và dữ liệu đã cho.
Nếu bạn muốn sử dụng phiên bản có thể thay đổi, hãy sử dụng phương thức [bytearray()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-7)
Trong đó:
+ source: là nguồn để khởi tạo mảng byte.
+ encoding: nếu nguồn là một chuỗi, thì mã hóa của chuỗi.
+ errors: nếu nguồn là một chuỗi, hành động sẽ được thực hiện khi chuyển đổi mã hóa bị lỗi.
Các tham số nguồn khác nhau:
+ String: Chuyển đổi chuỗi thành byte bằng `str.encode()` Cũng phải cung cấp mã hóa  và các lỗi tùy chọn
+ Integer: Tạo một mảng có kích thước được cung cấp, tất cả được khởi tạo thành `null`
+ Object: Bộ đệm chỉ đọc của đối tượng sẽ được sử dụng để khởi tạo mảng `byte`
+ iterable: Tạo một mảng có kích thước bằng số lần lặp và được khởi tạo thành các phần tử có thể lặp lại Phải lặp lại các số nguyên giữa `0 <= x <256`
+ No source: Tạo một mảng có kích thước `0`
```py
# Đối với source là string
>>> string = "0xpan.blogspot.com."
>>> arr = bytes(string, 'utf-8')
>>> print(arr)
b'0xpan.blogspot.com.'
# Đối với source là integer
>>> size = 5
>>> arr = bytes(size)
>>> print(arr)
b'\x00\x00\x00\x00\x00'
# Đối với source là iterable list
>>> rList = [1, 2, 3, 4, 5]
>>> arr = bytes(rList)
>>> print(arr)
b'\x01\x02\x03\x04\x05'
```

#### callable(object)
Hàm `ccallable()` kiểm tra một `object` có thể gọi được hay không, hàm trả về `True` nếu đối số đối tượng được truyền có thể gọi. Nếu không, nó sẽ trả về `False`.
Tuy nhiên, ngay cả khi `callable()` là `True`, lời gọi tới đối tượng vẫn có thể thất bại. Nhưng nếu `callable()` trả về `False`, cuộc gọi đến đối tượng chắc chắn sẽ thất bại.
Lưu ý rằng `class` là một đối tượng `callable` (gọi một `class` sẽ trả về một đối tượng mới); và các đối tượng có thể gọi được nếu lớp của chúng có một phương thức `__call__()`.
```py
>>> callable(5)
False
def testFunction():
  print("Test")
y = testFunction
callable(y)
True
```
Ví dụ thứ 2, Đối tượng có thể gọi (`callable object`)
```py
class Foo:
  def __call__(self):
    print('Xin chào!')

print(callable(Foo))
True
# Chứng minh kết quả trên
InstanceOfFoo = Foo()
InstanceOfFoo() # đối tượng 'Foo' có thể gọi
Xin chào!
```
Ví dụ thứ 3, đối tượng là `callable` những không thể gọi.
```py
class Foo:
  def printLine(self):
    print('Print Something')

print(callable(Foo))
True
InstanceOfFoo = Foo()
InstanceOfFoo() # sẽ tạo ra lỗi, đối tượng 'Foo' không thể gọi
TypeError: 'Foo' object is not callable
```

#### chr(i)
Hàm `chr()` trả về một ký tự (một `string`) từ một số nguyên (đại diện cho điểm mã unicode của ký tự).
Phạm vi hợp lệ của số nguyên là từ `0` đến `1,114,111`. Nếu khác sẽ tạo ra một ngoại lệ `ValueError`.
```py
>>> chr(97)
a
>>> chr(65)
A
>>> chr(-1)
ValueError: chr() arg not in range(0x110000)
```
#### @classmethod
Hàm trả về một phương thức lớp cho hàm đã cho
Cú pháp của hàm là: `classmethod(function)` . Những bạn có thể sử dụng `decorator` định nghĩa hàm như sau:
```py
@classmethod
def func(cls, args...)
```
Hàm nhận một tham số đơn là `function`: Hàm cần được chuyển đổi thành một phương thức lớp
trả về một phương thức lớp cho hàm đã cho.
Một phương thức class là một phương thức được liên kết với một lớp chứ không phải đối tượng của nó. Nó không yêu cầu tạo ra một đối tượng `class`, giống như `staticmethod` .
`Class method` là phương thức thuộc về cả `class`. Khi thực thi, nó không dùng đến bất cứ `instance` của class đó. Thay vào đó, cả class sẽ được truyền thành tham số thứ nhất ( `cls`) của phương thức này.
Phương thức class method có thể được gọi bởi cả class và đối tượng của nó.
Sự khác biệt giữa một phương thức static và một phương thức `class` là:
+ Phương thức `static` không biết gì về lớp và chỉ giao dịch với các tham số
+ Phương thức `class` làm việc với class vì tham số của nó luôn là class của chính nó.
Phương thức `class` có thể được gọi đồng thời bởi class và đối tượng của nó.
```py
Class.classmethod()
Class().classmethod()
```
Nhưng cũng không có vấn đề gì vì  phương pháp `class` luôn gắn liền một class với tham số đầu tiên như chính lớp `cls` của nó .
Ví dụ tạo một phương thức `class` bằng `classmethod()`:
```py
class Person:
    age = 25
    def printAge(cls):
        print('The age is:', cls.age)
# Tạo phương thức PrintAge của class Person
Person.printAge = classmethod(Person.printAge)
Person.printAge()
The age is: 25
```
Ở đây, chúng ta có class Person, với biến `age` được gán cho 25.và một hàm chức năng `printAge` có một tham số duy nhất `cls` mà không phải là `self` như chúng ta thường dùng.
`cls` chấp nhận class `Person` như một tham số thay vì đối tượng/trường hợp của `Person`.
Bây giờ, chúng ta truyền phương thức này `Person.printAge` làm đối số cho hàm `classmethod.` Điều này chuyển đổi phương thức thành một phương thức `class` để nó chấp nhận tham số đầu tiên là một `class` (tức là `Person`).
Trong dòng cuối cùng, chúng ta gọi `printAge` mà không cần tạo một đối tượng `Person` như chúng ta làm cho các phương thức `static`. Điều này sẽ in ra biến `age` của lớp .
Khi nào chúng ta sẽ dùng `@classmethod`:
+ `Factory methods`
```py
from datetime import date
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    @classmethod
    def fromBirthYear(cls, name, birthYear):
        return cls(name, date.today().year - birthYear)
    def display(self):
        print(self.name + "'s age is: " + str(self.age))
person = Person('Adam', 19)
person.display()
Adams age is: 19
person1 = Person.fromBirthYear('John',  1985)
person1.display()
Johns age is: 31
```
Ở đây, chúng ta có hai trình tạo đối tượng class, đó là `hàm tạo` (Constructor) và phương thức `fromBirthYear`. Constructor lấy tham số thông thường `name` và `age`. Trong khi, `fromBirthYear` lấy `class`, `name` và `birthYear`, tính toán độ tuổi hiện tại bằng cách trừ nó với năm hiện tại và trả về cho đối tượng class.
Phương thức `fromBirthYear` nhận class `Person` (không phải đối tượng của Person) khi tham số đầu tiên `cls` và trả về `hàm tạo` bằng cách gọi `cls(name, date.today().year - birthYear)`, tương đương với `Person(name, date.today().year - birthYear)`.
Ở đây, chúng ta thấy` @classmethod`. Điều này gọi là một [decorator](http://0xpan.blogspot.com/2018/11/decorator-trong-python.html) để chuyển đổi `fromBirthYear` thành một phương thức `class` như `classmethod()`.
+ Tạo đối tượng đúng trong thừa kế
```py
from datetime import date

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def fromBirthYear(cls, name, birthYear):
        return cls(name, date.today().year - birthYear)

    def display(self):
        print(self.name + "'có số tuổi là: " + str(self.age))

person = Person('An', 19)
person.display()
An có số tuổi là: 19
person1 = Person.fromBirthYear('Minh',  1985)
person1.display()
An có số tuổi là: 31
```
Ở đây, sử dụng một phương thức `static` để tạo một thuộc tính của lớp với mong muốn chúng ta mã hóa kiểu cá thể trong khi tạo. Điều này làm rõ một vấn đề khi kế thừa `Man` từ `Person`. Phương thức `fromFathersAge` không trả về một đối tượng `Man` mà là đối tượng của lớp cơ sở của nó `Person`.
Điều này vi phạm mô hình `OOP`. Sử dụng một phương thức class như `fromBirthYear` có thể đảm bảo `OOP-Ness` của mã vì nó lấy tham số đầu tiên là chính lớp đó và gọi phương thức `factory` của nó.

#### compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)
Hàm `compile()` được sử dụng khi bạn có mã nguồn Python ở dạng chuỗi và bạn muốn biến nó thành một đối tượng mã Python mà bạn có thể giữ và sử dụng.
Về cơ bản, đối tượng mã chuyển đổi một chuỗi thành một đối tượng mà sau này bạn có thể gọi [exec()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-20) để chạy mã nguồn trong chuỗi. (Với chế độ `exec`, còn chế độ `eval` cho phép sử dụng [eval()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-19) thay vào đó, nếu chuỗi chứa code cho một biểu thức.) Đây không phải là một việc làm phổ biến, nên đó là lí do vì sao bạn ít dùng đến nó.

Việc sử dụng chính của nó là trong `metaprogramming` hoặc lập trình nhúng. Ví dụ, nếu bạn có một chương trình Python cho phép người dùng viết hành vi của nó bằng mã Python tùy chỉnh, bạn có thể sử dụng `compile` và `exec` lưu trữ và thực thi các tập lệnh do người dùng định nghĩa này.

Một lý do khác `compile` ít được sử dụng là, cùng như `exec`, `eval`, ..., `compile` có thể nói là một lỗ hổng bảo mật tiềm ẩn. Nếu bạn lấy mã người dùng dưới dạng chuỗi và biên dịch nó và sau đó thực hiện nó, bạn có thể đang chạy mã không an toàn.
+ `source`: một chuỗi bình thường, một chuỗi byte hoặc một đối tượng AST
+ `filename`: tệp mà từ đó mã được đọc. Nếu nó không được đọc từ một tập tin, bạn có thể tự đặt tên cho mình
+ `mode`: Tùy chọn 1 trong 3 phương thức sau:
- `eval`: chỉ chấp nhận một biểu thức duy nhất.
- `exec`: Có thể lấy một khối mã có các câu lệnh Python, lớp và các hàm và vân vân.
- `single`: nếu nó bao gồm một câu lệnh tương tác duy nhất
+ `flags` và `dont_inherit`: kiểm soát các câu lệnh nào trong tương lai ảnh hưởng đến việc biên dịch nguồn. Giá trị mặc định: 0
+ `optimize`: mức tối ưu hóa của trình biên dịch. Giá trị mặc định -1.
```py
codeInString = 'a = 5\nb=6\nsum=a+b\nprint("sum =",sum)'
codeObejct = compile(codeInString, 'sumstring', 'exec')
exec(codeObejct)
sum = 11
```
Ở đây, `source` ở dạng chuỗi bình thường. `filename` là chuỗi `sumstring`. Và, chế độ `exec` này sau đó cho phép sử dụng phương thức  `exec()`.
Phương thức `compile()` chuyển đổi chuỗi thành đối tượng mã Python. Đối tượng mã sau đó được thực hiện bằng phương thức `exec()`.

#### complex([real[, imag]])
Hàm trả về một số phức khi các phần thực và phần ảo được cung cấp, hoặc nó chuyển đổi một chuỗi thành một số phức.
Hàm nhận hai tham số:
+ `real` (phần thực): Nếu thực sự bị bỏ qua, nó mặc định là `0`.
+ `imag` (phần ảo): Nếu `imag` được bỏ qua, nó mặc định `0`.
Nếu tham số đầu tiên được truyền cho phương thức này là một chuỗi, thì nó sẽ được hiểu là một số phức. Trong trường hợp này, tham số thứ hai không được thông qua.
```py
>>> complex(2, -3)
(2 -3j)
>>> complex(1)
(1 + 0j)
>>> complex()
0j
>>> complex('5-9j')
(5-9j)
```
Tạo số `complex` không sử dụng hàm `complex()`:
```py
>>> a = 2+3j
>>> print('a =',a)
a = (2+3j)
>>> print('Kiểu của a là:',type(a))
#Kiểu của a là: <class>
>>> b = -2j
>>> print('b =',b)
b = (-0-2j)
>>> print('Kiểu của b là:',type(a))
#Kiểu của a là: <class>
>>> print('c =',c)
c = 0j
>>> c = 0j
>>> print('Kiểu của c là:',type(c))
#Kiểu của a là: <class>
```

#### delattr(object, name)
Hàm xóa một thuộc tính khỏi đối tượng (nếu đối tượng cho phép điều đó). Và nó không trả về bất kỳ giá trị nào (trả về `None`)
Hàm nhận 2 tham số:
+ `object`: Đối tượng chứa thuộc tính `name` sẽ bị loại bỏ
+ `name`: Tên của đối tượng sẽ bị loại bỏ (kiểu `string`)
```py
class Coordinate:
  x, y, z = 10, -5, 0
point1 = Coordinate() 
print(point1.x)
10
print(point1.y)
-5
print(point1.z)
0
delattr(Coordinate, 'z')
print('--Sau khi xóa thuộc tính z --')
print(point1.x)
10
print(point1.y)
-5 
print(point1.z)
AttributeError: 'Coordinate' object has no attribute 'z'
```

#### dict()
Hàm sẽ tạo một kiểu dữ liệu `dictionary` từ các giá trị được cung cấp.
Có 3 cách xấy dựng hàm `dict()`:
```py
class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)
```
Lưu ý: `**kwarg` cho phép bạn có số lượng đối số từ khóa tùy ý.
Đối số từ khóa là đối số được đặt trước bởi một số nhận dạng (ví dụ `name= `). Do đó, đối số từ khóa của biểu mẫu `kwarg=value` được chuyển tới hàm dict () để tạo từ điển.
`dict()` không trả về bất kỳ giá trị nào (trả về `None`).
```py
>>> numbers = dict(x=5, y=0)
>>> numbers
{'x': 5, 'y': 0}
>>> type(numbers)
#<class 'dict'>
>>> empty = dict()
>>> empty
{}
>>> type(empty)
#<class 'dict'>
```
Ví dụ thứ 2, tạo `dict` sử dụng `iterable`:
```py
# tham số **kwarg không được cung cấp
numbers1 = dict([('x', 5), ('y', -5)])
print(numbers1)
{'y': -5, 'x': 5}
# tham số **kwarg được cung cấp
numbers2 = dict([('x', 5), ('y', -5)], z=8)
print(numbers2)
{'z': 8, 'y': -5, 'x': 5}
# zip() tạo 1 iterable trong python3
numbers3 = dict(dict(zip(['x', 'y', 'z'], [1, 2, 3])))
print(numbers3)
{'z': 3, 'y': 2, 'x': 1}
```
Ví dụ thứ 2, tạo `dict` sử dụng `mapping`:
```py
numbers1 = dict({'x': 4, 'y': 5})
print(numbers1)
{'x': 4, 'y': 5}
# trường hợp không cần sử dụng hàm dict() 
numbers2 = {'x': 4, 'y': 5}
print(numbers2)
{'x': 4, 'y': 5}
# tham số **kwarg được cung cấp
numbers3 = dict({'x': 4, 'y': 5}, z=8)
print(numbers3)
{'x': 4, 'z': 8, 'y': 5}
```

#### dir([object])
Hàm nhận tối đa một đối tượng và cố gắng trả về tất cả các thuộc tính của đối tượng này. 
+ Nếu không có đối số, hàm trả về danh sách tên trong phạm vi cục bộ hiện tại.
+ Nếu đối tượng có phương thức `__dir__()`, phương thức sẽ được gọi và phải trả về danh sách các thuộc tính. Điều này cho phép các đối tượng thực hiện một phương thức tùy chỉnh `__getattr__()` hoặc `__getattribute__()` để tùy chỉnh kết quả `dir()` trả về.
+ Nếu đối tượng không có phương thức `__dir__()` , phương thức này cố tìm thông tin từ thuộc tính `__dict__` (nếu được định nghĩa) của đối tượng. Trong trường hợp này, danh sách kết quả có thể không phải hoàn thành và có thể không chính xác khi đối tượng có thuộc tính tùy chỉnh `__getattr__()`.
+ Danh sách kết quả sẽ được sắp xếp theo thứ tự bảng chữ cái.
Hàm `dir()` mặc định hoạt động khác nhau với các loại đối tượng khác nhau, vì nó cố gắng tạo ra thông tin có liên quan, chứ không phải là hoàn chỉnh nhất:
+ Nếu đối tượng là một đối tượng `module`, danh sách trả về sẽ chứa tên của các thuộc tính của mô-đun.
+ Nếu đối tượng là một kiểu hoặc đối tượng lớp, danh sách chứa tên các thuộc tính của nó và đệ quy các thuộc tính của các cơ sở của nó.
+ Nếu không, danh sách này chứa tên các thuộc tính của đối tượng, tên của các thuộc tính của lớp đó và đệ quy các thuộc tính của các lớp cơ sở của lớp đó.

```py
>>> number = [1, 2, 3]
>>> dir(number)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
# Trả về giá trị của dir() rỗng
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'number', 'numbers']
```
Hàm `dir()` với đối tượng người dùng tự định nghĩa
```py
class Person:
  def __dir__(self):
    return ['age', 'name', 'salary']
teacher = Person()
print(dir(teacher))
['age', 'name', 'salary']
```
Chú thích:
Hàm `dir()` được cung cấp nhằm mục đích chủ yếu như một sự gợi nhớ để sử dụng trong chế tương tác, nó cố gắng cung cấp một bộ tên gợi ý hơn là cố gắng cung cấp một tập hợp các tên được xác định chặt chẽ hoặc nhất quán, và hành vi chi tiết của nó có thể thay đổi qua các bản Python khác nhau. 
Ví dụ, các thuộc tính `metaclass` không có trong danh sách kết quả khi đối số là một lớp.

####  divmod(x, y)
Hàm nhận hai tham số, và trả về một cặp số (tuple) bao gồm thương và số dư của chúng. Tương đương với (`a // b`, `x % y`). Đối với các kiểu toán hạng hỗn hợp, các quy tắc cho toán tử nhị phân sẽ được áp dụng.
Đối với `x` và `y` là số nguyên, kết quả trả về sẽ giống với `(a // b, a % b)`, còn nếu 1 trong 2 tham số là `float` thì kết quả trả về sẽ có dạng `(q, a % b)`. Trong đó `q` thường là `math.floor(a/b)` nhưng có thể nhỏ hơn giá trị đó `1` đơn vị.
Trong bất kì trường hợp nào `q * b + a % b` là gần bằng `a`, nếu `a%b` khác không, nó có cùng dấu với `b`, và `0 <= abs(a % b) < abs(b)`.
```py
divmod(8, 3)
(2, 2)
divmod(3, 8)
(0, 3)
divmod(8.0, 3)
(2.0, 2.0)
divmod(7.5, 2.5)
(3.0, 0.0)
```

#### enumerate(iterable, start=0)
Phương thức enumerate() thêm số đếm vào một `iterable` và trả về cặp `(index, value)` của `iterable` đó.
Tham số `iterable` có thể là một chuỗi, một `iterator` hoặc một đối tượng hỗ trợ `iteration`.
Tham số `start` để chỉ vị trí bắt đầu đếm của giá trị `index`, và mặc định là `0` nếu không được thiết lập.
```py
>>> grocery = ['bread', 'milk', 'butter']
>>> list(enumerate(grocery))
[(0, 'bread'), (1, 'milk'), (2, 'butter')]
>>> list(enumerate(grocery, 10))
[(10, 'bread'), (11, 'milk'), (12, 'butter')]
for i in enumerate('hello'):
    print i
(0, 'h')
(1, 'e')
(2, 'l')
(3, 'l')
(4, 'o')
```
Ví dụ 2, lặp lại một đối tượng `enumerate`
```py
grocery = ['bread', 'milk', 'butter']

for item in enumerate(grocery):
  print(item)

(0, 'bread')
(1, 'milk')
(2, 'butter')

print('\n')
for count, item in enumerate(grocery):
  print(count, item)

0 bread
1 milk
2 butter

print('\n')
# thay đổi giá trị bắt đầu mặc định
for count, item in enumerate(grocery, 100):
  print(count, item)
100 bread
101 milk
102 butter
```

#### eval(expression, globals=None, locals=None)
Hàm phân tích cú pháp biểu thức (`expression`) được truyền cho phương thức này và chạy biểu thức python (được thông qua như một đối số) trong chương trình và trả về kết quả được đánh giá từ `expression`
Hàm nhận ba tham số:
+ `expression`: chuỗi này được phân tích cú pháp và được đánh giá dưới dạng biểu thức Python
+ `globals`: 1 dictonary
+ `local`: một đối tượng mapping. Từ điển là kiểu ánh xạ chuẩn và thường được sử dụng trong Python.
```py
>>> x = 1
>>> print(eval('x + 1'))
2
```
Ở đây, hàm `eval()` đánh giá biểu thức `x + 1` và in nó.
```py
# Chu vi hình vuông
def calculatePerimeter(l):
  return 4*l
# Diện tích
def calculateArea(l):
  return l*1
property = input("Nhập vào 1 hàm: ")
for l in range(1, 5):
    if (property == 'calculatePerimeter(l)'):
        print("Nếu chiều dài là ", l , ", Chu vi là = ", eval(property))
    elif (property == 'calculateArea(l)'):
    print("Nếu chiều dài là ", l , ", Diện tích là = ", eval(property))
    else:
      print('hàm không chính xác')
      break
calculateArea(l)
If length is  1 , Area =  1
If length is  2 , Area =  2
If length is  3 , Area =  3
If length is  4 , Area =  4
```
** Bạn nên hạn chế sử dụng `eval()`
Ví dụ bạn đang sử dụng một hệ thống Unix (macOS, Linux, vv) và bạn `import module os`. Mô-đun `os` cung cấp cách nhanh chóng để sử dụng các chức năng của hệ điều hành như: đọc hoặc ghi tệp.
Nếu bạn cho phép người dùng nhập giá trị bằng cách sử dụng `eval(input())`, người dùng có thể ra lệnh thay đổi tệp hoặc thậm chí xóa tất cả các tệp bằng lệnh `os.system('rm -rf *')`.
Nếu bạn đang sử dụng `eval(input())` trong mã của mình, bạn nên kiểm tra xem các biến và phương thức nào người dùng có thể sử dụng. Bạn có thể thấy các biến và phương thức nào có sẵn bằng phương thức `dir()` .
```py
from math import *
print(eval('dir()'))
['Person', '__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'number', 'numbers', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'teacher', 'trunc']
```
** Hạn chế sử dụng các phương thức và biến có sẵn trong `eval()`
Hầu hết, tất cả các phương thức và biến có sẵn được sử dụng trong `expression` có thể không cần thiết, hoặc thậm chí có thể có lỗ hổng bảo mật. Bạn có thể cần phải hạn chế việc sử dụng các phương thức và biến này cho `eval()`. Bạn có thể làm như vậy bằng cách thông qua tùy chọn `globals` và `local` .
+ Khi cả hai tham số `globals` và `locals` bị bỏ qua:
Nếu cả hai tham số được bỏ qua (như trong các ví dụ trước đó của chúng tôi), thì biểu thức được thực hiện trong phạm vi hiện tại. Bạn có thể kiểm tra các biến và phương thức có sẵn bằng cách sử dụng mã sau:
```py
print(eval('dir()'))
```
+ Tham số `globals` được sử dụng; tham số `local` bị bỏ qua:
Các tham số `globals` và `locals` được sử dụng cho các biến toàn cục và cục bộ tương ứng. Nếu `local` bị bỏ qua, nó mặc định là `globals`. Có nghĩa là, `globals` sẽ được sử dụng cho cả biến toàn cầu và cục bộ.
Lưu ý: Bạn có thể kiểm tra từ điển toàn cầu và cục bộ hiện tại bằng Python bằng cách sử dụng các phương thức được xây dựng sẵn trong `globals()` và `local()` tương ứng.
+ sử dụng cả `globals` và `local`:
```py
from math import *
a = 5
print(eval('sqrt(a)', {'__builtins__': None}, {'a': a, 'sqrt': sqrt}))
2.23606797749979 
```
Trong chương trình này, `expression`  có thể có phương thức `sqrt()` và chỉ biến `a` . Tất cả các phương thức và biến khác không có sẵn.
Hạn chế việc sử dụng `eval()` bằng cách đi qua `globals` và `local` sẽ làm cho mã của bạn an toàn đặc biệt là khi bạn đang sử dụng đầu vào được cung cấp bởi người dùngbằng phương thức `eval()`.

#### exec(object, globals, locals)
Hàm thực hiện chương trình được tạo động, đó là một chuỗi hoặc một đối tượng mã và không trả về bất kỳ giá trị nào, nó trả về `None`.
Nếu nó là một chuỗi, chuỗi được phân tích cú pháp như là một bộ các câu lệnh Python mà sau đó được thực hiện (trừ khi xảy ra lỗi cú pháp).Nếu nó là một đối tượng mã, nó được thực hiện đơn giản
Hàm nhận ba tham số:
+ `object`: có thể là chuỗi hoặc mã đối tượng.
+ `globals`: 1 dictonary.
+ `local`: một đối tượng mapping. Từ điển là kiểu ánh xạ chuẩn và thường được sử dụng trong Python.
```py
program = 'a = 5\nb=10\nprint("Tổng =", a+b)'
exec(program)
Tổng = 15
```
Ví dụ 2, cho phép người dùng nhập đầu vào
```py
program = input('Nhập vào 1 chương trình:')
exec(program)
Nhập vào 1 chương trình: [print(item) for item in [1, 2, 3]]
1
2
3
```
Nếu bạn muốn lấy mã Python từ người dùng cho phép mã chạy nhiều dòng (sử dụng `\n`), bạn có thể sử dụng phương thức [compile()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-12) trước khi sử dụng `exec()`.
** Bạn nên hạn chế sử dụng `exec()`
Ví dụ bạn đang sử dụng một hệ thống Unix (macOS, Linux, vv) và bạn `import module os`. Mô-đun `os` cung cấp cách nhanh chóng để sử dụng các chức năng của hệ điều hành như: đọc hoặc ghi tệp.
Nếu bạn cho phép người dùng nhập giá trị bằng cách sử dụng `exec(input())`, người dùng có thể ra lệnh thay đổi tệp hoặc thậm chí xóa tất cả các tệp bằng lệnh `os.system('rm -rf *')`.
Nếu bạn đang sử dụng `exec(input())` trong mã của mình, bạn nên kiểm tra xem các biến và phương thức nào người dùng có thể sử dụng. Bạn có thể thấy các biến và phương thức nào có sẵn bằng phương thức `dir()` .
```py
from math import *
print(eval('dir()'))
['Person', '__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'number', 'numbers', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'teacher', 'trunc']
```
** Hạn chế sử dụng các phương thức và biến có sẵn trong `exec()`
Hầu hết, tất cả các phương thức và biến có sẵn được sử dụng trong `exec()` có thể không cần thiết, hoặc thậm chí có thể có lỗ hổng bảo mật. Bạn có thể cần phải hạn chế việc sử dụng các phương thức và biến này cho `eval()`. Bạn có thể làm như vậy bằng cách thông qua tùy chọn `globals` và `local` .
+ Khi cả hai tham số `globals` và `locals` bị bỏ qua:
Nếu cả hai tham số được bỏ qua (như trong các ví dụ trước đó của chúng tôi), thì biểu thức được thực hiện trong phạm vi hiện tại. Bạn có thể kiểm tra các biến và phương thức có sẵn bằng cách sử dụng mã sau:
```py
exec('print(dir())')
```
+ Tham số `globals` được sử dụng; tham số `local` bị bỏ qua:
Các tham số `globals` và `locals` được sử dụng cho các biến toàn cục và cục bộ tương ứng. Nếu `local` bị bỏ qua, nó mặc định là `globals`. Có nghĩa là, `globals` sẽ được sử dụng cho cả biến toàn cầu và cục bộ.
Lưu ý: Bạn có thể kiểm tra từ điển toàn cầu và cục bộ hiện tại bằng Python bằng cách sử dụng các phương thức được xây dựng sẵn trong `globals()` và `local()` tương ứng.

Chuyển từ điển trống thành tham số `global`:
```py
from math import *
exec('print(dir())', {})
['__builtins__']
```
Nếu bạn bỏ qua từ điển rỗng như `globals` , chỉ có ` __builtins__` cho object(tham số đầu tiên với `exec()`). Mặc dù chúng tôi đã nhập mô-đun toán học trong chương trình trên, cố gắng truy cập vào bất kỳ chức năng nào được cung cấp bởi mô-đun toán học sẽ tạo ra ngoại lệ.
Tạo một phương thức đúng
```py
from math import *
exec('print(dir())', {'sqrt': sqrt, 'pow': pow})
exec('print(sqrt(9))', {'sqrt': sqrt, 'pow': pow})
```
Bạn có thể hạn chế việc sử dụng `__builtins__` bằng cách đưa giá trị `None` vào `__builtins__` trong từ điển `globals` .
+ sử dụng cả `globals` và `local`:
Bạn có thể tạo các hàm và biến cần thiết để sử dụng bằng cách chuyển từ điển `local`. Ví dụ:
```py
from math import *
globalsParameter = {'__builtins__' : None}
localsParameter = {'print': print, 'dir': dir}
exec('print(dir())', globalsParameter, localsParameter)
['dir', 'print']
```
Ở đây, chỉ có hai phương thức tích hợp `print()` và `dir()` có thể được thực hiện bởi phương thức `exec()`.
Điều quan trọng cần lưu ý là, `exec()` thực thi mã và không trả về bất kỳ giá trị nào (trả về `None`). Do đó, bạn không thể sử dụng câu lệnh trả về và tuyên bố `yield` bên ngoài các định nghĩa hàm.

#### filter(function, iterable)
Hàm `filter()` xây dựng một `iterator` từ các phần tử của một iterable mà một hàm trả về `True`.
Nói một cách đơn giản, phương thức `filter()` lọc các `iterable` đã cho với sự trợ giúp của một hàm kiểm tra từng phần tử trong `iterable` là `True` hay không.
Bạn có thể xem thêm Hãy xem [itertools.filterfalse()](https://docs.python.org/3/library/itertools.html#itertools.filterfalse) hàm bổ sung trả về các phần tử có thể lặp lại mà hàm trả về `false`
```py
list(filter(lambda x: x in ['a','b','c'], 'alo'))
['a']
```
#### float([x])
Hàm `float()` trả về một số dấu chấm động từ một số hoặc một chuỗi.
Yêu cầu đối với chuỗi:
+ Phải chứa số thập phân. 
+ Các khoảng trống đầu và cuối được xóa. 
+ Tùy chọn sử dụng dấu `+`, `-`. 
+ Có thể chứa `NaN, Infinity, inf` (chữ thường hoặc chữ hoa)
Các giá trị mà hàm sẽ trả về:
+ Số `float` tương đương nếu một đối số được chuyển
+ `0,0` nếu không có đối số nào được chuyển
+ `OverflowError` ngoại lệ nếu đối số nằm ngoài phạm vi của float Python
```py
print(float("-13.33"))
-13.33
print(float("     -24.45\n"))
-24.45
print(float("abc"))
ValueError: could not convert string to float: 'abc'
print(float("nan"))
nan
print(float("NaN"))
nan
print(float("inf"))
inf
print(float("InF"))
inf
print(float("InFiNiTy"))
inf
print(float("infinity"))
inf
```

#### format(value[, format_spec])
Hàm trả về một biểu diễn được định dạng của giá trị đã cho được kiểm soát bởi trình định dạng. Tương tự như phương thức định dạng `String`. Bên trong, cả hai phương thức đều gọi phương thức `__format __ ()` của một đối tượng.
Bạn có thể tham khảo [String in Python ](https://0xpan.blogspot.com/2018/11/string-in-python.html) để tham khảo cá loại định dạng và căn chỉnh.
```py
# integer 
print(format(1234, "*>+7,d"))
print(format(1234, "*>+7,d"))
# float number
print(format(123.4567, "^-09.3f"))
0123.4570
```

#### frozenset([iterable])
Hàm trả về một đối tượng frozenset bất biến được khởi tạo với các phần tử từ vòng lặp đã cho.
Frozenset chỉ là một phiên bản bất biến của một đối tượng `set` của Python . Mặc dù các phần tử của tập hợp có thể được sửa đổi bất kỳ lúc nào, các phần tử của tập hợp đã được giữ nguyên vẫn giữ nguyên sau khi tạo.
Do đó, tập hợp có thể được sử dụng làm khóa trong `Dictionary` hoặc làm phần tử của một tập hợp khác. Nhưng giống như `set`, nó không được sắp xếp thứ tự (các phần tử có thể được đặt ở bất kỳ chỉ mục nào).
```py
# tuple 
>>> vowels = ('a', 'e', 'i', 'o', 'u')
>>> fSet = frozenset(vowels)
>>> fSet
frozenset({'i', 'a', 'u', 'e', 'o'})
# dict
>>> person = {"name": "John", "age": 23, "sex": "male"}
>>> fSet = frozenset(person)
>>> fSet
frozenset({'name', 'sex', 'age'})
```
Giống như `set` bình thường, frozenset cũng có thể thực hiện các hoạt động khác nhau như `union`, `intersection`, v.v.

#### getattr(object, name[, default])
Cú pháp tương tự `object.name`. Hàm nhận các tham số:
+ object: đối tượng có giá trị của thuộc tính được đặt tên sẽ được trả về.
+ name: string chứa tên của thuộc tính.
+ default: giá trị được trả về khi không tìm thấy thuộc tính được đặt tên.
Hàm trả về:
+ giá trị của thuộc tính được đặt tên của đối tượng đã cho.
+ giá trị `default` nếu không tìm thấy thuộc tính được đặt tên.
+ Ngoại lệ `AttributeError`, nếu không tìm thấy thuộc tính được đặt tên và `default` không được xác định.
```py
class Person:
    age = 23
    name = "An"

person = Person()
print(getattr(person, "age"))
23
print(person.age)
23
```
Và với trường hợp tên của thuộc tính không được tìm thấy.
```py
class Person:
    age = 23
    name = "An"
person = Person()
# Khi giá trị default được áp dụng
print(getattr(person, 'sex', 'Male'))
Male
# Khi không có giá trị default được áp dụng
print(getattr(person, 'sex'))
Male
AttributeError: 'Person' object has no attribute 'sex'
```

#### globals()
Hàm không nhận bất kỳ tham số nào và trả về 1 `dict` của tất cả các thông tin về biến cục bộ liên quan của module hiện tại (bên trong một hàm, đây là một module mà nó được định nghĩa, không phải là module mà nó được gọi).
Chúng bao gồm tên biến, phương thức, lớp, v.v.
```py
globals()
{'__builtins__': <module '__builtin__' (built-in)>, '__name__': '__main__', '__doc__': None, '__package__': None}
```
Ta có thể sửa đổi biến `global` bằng cách:
```py
age = 23
globals()['age'] = 25
print(age)
25
```

#### hasattr(object, name)
Hàm trả về `True` nếu một đối tượng có thuộc tính được đặt tên và `False` nếu nó không có. Hàm được gọi bởi `getattr()` để kiểm tra xem `AttributeError` có có xảy ra hay không.
```py
class Person:
    age = 23
    name = 'Adam'
person = Person()
print(hasattr(person, 'age'))
True
print(hasattr(person, 'salary'))
False
```

#### hash(object)
Hàm trả về giá trị băm của một đối tượng nếu nó có giá trị băm. Giá trị băm chỉ là số nguyên được sử dụng để so sánh các khóa từ điển trong quá trình tra cứu từ điển một cách nhanh chóng.Nếu một đối tượng có phương thức `__hash__()` tùy chỉnh, nó sẽ cắt bớt giá trị trả về thành kích thước của `Py_ssize_t` .
Bên trong, phương thức `hash()` gọi phương thức `__hash__()` của một đối tượng và nó được đặt mặc định cho bất kỳ đối tượng nào.
```py
hash(181)
181
hash('Python')
2230730083538390373
hash(('a', 'e', 'i', 'o', 'u'))
-695778075465126279
```
** Hàm `hash()` với các đối tượng tùy chỉnh
Như đã nói ở trên, phương thức `hash()` gọi phương thức `__hash__()` nội bộ. Vì vậy, bất kỳ đối tượng nào cũng có thể ghi đè `__hash__()` cho các giá trị băm tùy chỉnh.
Nhưng để thực hiện băm đúng, `__hash __()` phải luôn trả về một số nguyên. Và, cả hai phương thức `__eq __()` và `__hash __()` đều phải được thực hiện.
Dưới đây là các trường hợp ghi đè đúng `__hash __()`:

| __eq__() | __hash__() | Sự miêu tả |
|----------|-----------|--------------------------------------------------|
| Được xác định | Được xác định | Tất cả các đối tượng sẽ so sánh không bằng nhau (ngoại trừ chính chúng) |
| Được xác định | Không nên xác định | Việc triển khai tập hợp có thể băm yêu cầu giá trị băm của khóa không thay đổi được |
| Không xác định | Không nên xác định | Nếu `__eq __()` không được xác định, `__hash __()` không được xác định. |
| Được định nghĩa | Không xác định | Các thuộc tính của class sẽ không thể sử dụng được dưới dạng bộ sưu tập có thể băm. `__hash __()` được đặt thành `None`. Tạo ngoại lệ `TypeError` nếu cố gắng truy lục hàm băm.|
| Được định nghĩa | Giữ lại từ lớp cha | `__hash__ = <ParentClass>.__ hash__` |
| Được định nghĩa | Không muốn băm | `__hash__ = None`. Tạo ngoại lệ `TypeError` nếu cố gắng truy lục hàm băm.|

```py
class Person:
    def __init__(self, age, name):
        self.age = age
        self.name = name

    def __eq__(self, other):
        return self.age == other.age and self.name == other.name

    def __hash__(self):
        print('The hash is:')
        return hash((self.age, self.name))

person = Person(23, 'Adam')
hash(person)
3785419240612877014
```
Lưu ý: bạn không phải triển khai phương thức `__eq __()` cho hàm băm vì nó được tạo mặc định cho tất cả các đối tượng.

#### help(object)
Hàm gọi hệ thống trợ giúp của Python được dựng sẵn. Được sử dụng để sử dụng tương tác. Nó được giới thiệu để thử nó trong trình thông dịch của bạn khi bạn cần trợ giúp để viết chương trình Python và sử dụng các mô-đun Python và nó không nhận đối số nào.
```py
>>> help(list)
>>> help(dict)
>>> help(print)
>>> help([1, 2, 3])
```
Hoặc
```py
>>> help()
help> 'print'
help > print
help > quit 3 Để quay trở lại trình thông dịch
```
#### hex(x)
Hàm chuyển đổi một số nguyên thành chuỗi thập lục phân tương ứng dưới dạng chuỗi và trả về nó. Chuỗi thập lục phân được trả về bắt đầu bằng tiền tố `0x` biểu thị nó ở dạng thập lục phân.
Hàm nhận tham số `x`: phải là số integer ( đối tượng `int` hoặc được định nghĩa bởi phuwong thức `__index__()` và trả về như một số `integer`)
```py
>>> hex(435)
0x1b3
>>> hex(0)
0x0
>>> float.hex(2.5)
0x1.4000000000000p+1
```

#### id(object)
Hàm trả về nhận dạng (số nguyên duy nhất) của một đối tượng. Đây là một số nguyên duy nhất cho đối tượng đã cho và vẫn không đổi trong suốt thời gian tồn tại của nó
```py
>>> id(5)
50227512L
>>> b = 5*6
>>> id(b)
50226912L
```

#### input([prompt])
Hàm đọc một dòng từ đầu vào, chuyển đổi thành một chuỗi và trả về nó.
Đối số `prompt` thường là một chuỗi được ghi vào đầu ra tiêu chuẩn (thường là màn hình) mà không có dấu dòng mới
```py
inputString = input('Enter a string:')
print('The inputted string is:', inputString)
Enter a string: Python is interesting.
The inputted string is: Python is interesting
```

#### int(x=0, base=10)
Phương thức `int()` trả về một đối tượng số nguyên từ bất kỳ số hoặc chuỗi nào.
Phương thức `int()` nhận hai đối số:
+ `x`: Số hoặc chuỗi được chuyển đổi thành đối tượng số nguyên. Đối số mặc định bằng 0.
+ `base`: Căn cứ của số trong `x`. Có thể là `0` (mã chữ) hoặc `2-36.`
Và hàm trả về:
+ một đối tượng số nguyên từ số hoặc chuỗi đã cho, xử lý cơ sở mặc định là `10` (Không có tham số) trả về `0`.
+ Nếu `base` được thiết lập thì xử lý chuỗi trong cơ sở đã cho (`0`, `2`, `8`, `10`, `16`)
```py
int('123')
123
```

#### isinstance(object, classinfo)
Hàm kiểm tra nếu`object` (đối số đầu tiên) có phải là một cá thể hoặc lớp con của lớp `classinfo` (đối số thứ hai). `classinfo` có thể là `class`, `type` hoặc `tuple` của các lớp và kiểu. Hàm trả về `True` nếu đúng, ngược lại là `False`.
```py
class Foo:
  a = 5
fooInstance = Foo()
print(isinstance(fooInstance, Foo))
True
print(isinstance(fooInstance, (list, tuple)))
False
print(isinstance(fooInstance, (list, tuple, Foo)))
True
```
Hoặc với Types:
```py
numbers = [1, 2, 3]

result = isinstance(numbers, list)
print(result)
True
result = isinstance(numbers, dict)
print(result)
False
```

#### issubclass(object, classinfo)
Hàm kiểm tra nếu đối số `object` (đối số đầu tiên) là một lớp con của lớp `classinfo` (đối số thứ hai).
Các tham số và cách viết giống với hàm [isinstance()](https://iamfinn.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-34).


#### iter(object[, sentinel])
Hàm trả về một trình lặp cho đối tượng đã cho.Hàm tạo ra một đối tượng có thể được lặp lại một phần tử tại một thời điểm. Các đối tượng này hữu ích khi kết hợp với các vòng lặp như `for`, `while`.
Trong trường hợp `sentinel` được cung cấp, nó trả về đối tượng `iterator` gọi các đối tượng `callable` cho đến khi kí tự `sentinel` không được tìm thấy.
Hàm nhận hai tham số:
+ `object`: đối tượng có trình vòng lặp phải được tạo (tuple, set , v.v.)
+ `sentinel` : giá trị đặc biệt được sử dụng để biểu diễn kết thúc chuỗi.
Tùy thuộc vào các đối số được thông qua, `iter()` phải có các thuộc tính sau đây tùy thuộc vào Các trường hợp khác nhau của tham số:

| object | sentinel | Miêu tả |
|---------|---------|----------|
| set, tuple | None | Tạo trình lặp cho đối tượng |
| Đối tượng do người dùng định nghĩa | None | thực hiện các phương thức `__iter__()` và `__next__()` thực hiện phương thức `__getitem__()` với các đối số nguyên bắt đầu từ `0`.
| Đối tượng do người dùng định nghĩ không thực hiện `__ite__()` và `__next__()` hoặc `__getitem__()` | None | Tạo ra ngoại lệ `TypeError`|
| Đối tượng callable | Được cung cấp | Trả về trình lặp mà gọi đối tượng với không có đối số cho mỗi cuộc gọi đến phương thức `__next__()` của nó. Nếu phát hiện thấy `sentinel`, tạo ra ngoại lệ `StopIteration`.

#### len(s)
Hàm `len()` trả về số lượng các mục (chiều dài) của một đối tượng (có thể string, tuple, list, dict, set..).
Không một đối số không hợp lệ sẽ tạo ra ngoại lệ `TypeError`.
```py
len('Hello')
5
len([1, 2, 3, 4, 5])
5
```
#### list([iterable])
Hàm tạo một `list` bằng Python. `interable` có thể là `string`, `tuple`, `set`, `dictonary`.
Nếu không có tham số nào được truyền, nó sẽ tạo ra một danh sách trống còn nếu `iterable` được chuyển thành tham số, nó sẽ tạo ra một danh sách các phần tử trong `iterable`.
```py
list((1,2,3,4))
[1, 2, 3, 4]
list({'a':1, 'b':2})
['a', 'b']
```
#### locals()
Hàm cập nhật và trả về một từ điển của bảng ký hiệu `local` hiện tại.
```py
locals()
{'__builtins__': <module '__builtin__' (built-in)>, '__name__': '__main__', 'b': 30, '__doc__': None, '__package__': None}
```
Ví dụ `locals()` hoạt động trong phạm vi `local`
```py
def localsNotPresent():
    return locals()
def localsPresent():
    present = True
    return locals()
print(localsNotPresent())
{}
print(localsPresent())
{'present': True}
```
Thay đổi giá trị dictonary `locals()`
```py
def localsPresent():
    present = True
    print(present)
    locals()['present'] = False;
    print(present)

localsPresent()
True
True
```
#### map(function, iterable, ...)
Hàm áp dụng `function` cho mỗi mục của một `iterable` (danh sách, tuple, vv) và trả về một danh sách các kết quả các kết quả. Giá trị trả về có thể sử dụng bởi hàm `list()` và `set()`...vv..
```py
def calculateSquare(n):
  return n*n
numbers = (1, 2, 3, 4)
result = map(calculateSquare, numbers)
print(result)
<map object at 0x7f722da129e8>
# chuyển giá trị map object thành set
numbersSquare = set(result)
print(numbersSquare)
{16, 1, 4, 9}
```
Áp dụng hàm `map()` với hàm `lambda`:
```py
numbers = (1, 2, 3, 4)
result = map(lambda x: x*x, numbers)
print(result)
<map 0x7fafc21ccb00>
# chuyển giá trị map object thành set
numbersSquare = set(result)
print(numbersSquare)
{16, 1, 4, 9}
```
Sử dụng nhiều `Iterators` với hàm `map()` sử dụng `lambda`:
```py
num1 = [4, 5, 6]
num2 = [5, 6, 7]
result = map(lambda n1, n2: n1+n2, num1, num2)
print(list(result))
[9, 11, 13]
```
#### `max(iterable, *iterables[,key, default])` hoặc `max(arg1, arg2, *args[, key])`
Phương thức max () trả về phần tử lớn nhất trong một hoặc nhiều tham số có thể lặp lại hoặc lớn nhất.
`max(iterable, *iterables[, key, default])`:
+ `iterable`:  ( tuple , string ), collection ( set , dictionary ) hoặc một đối tượng iterator có phần tử lớn nhất được tìm thấy
+ `*iterables`: bất kỳ số lần lặp nào có thể tìm thấy lớn nhất
+ `key`: chức năng khóa nơi các vòng lặp được truyền và việc so sánh được thực hiện dựa trên giá trị trả về của nó
+ `default`: giá trị mặc định nếu có thể lặp lại được
`max(arg1, arg2, *args[, key])`:
+ `arg1`: đối tượng đầu tiên bắt buộc để so sánh (có thể là số, chuỗi hoặc đối tượng khác)
+ `arg2`: đối tượng thứ hai bắt buộc để so sánh (có thể là số, chuỗi hoặc đối tượng khác)
+ `*args`:  các đối tượng khác để so sánh
+ `key`: Chức năng quan trọng mà mỗi đối số được thông qua, và so sánh được thực hiện dựa trên giá trị trả về của nó

Giá trị trả về đối với `max(iterable, *iterables[, key, default])`:

| Trường hợp | Key | default | Giá trị trả về |
|-------------|----------------|---------------|---------------|
| `iterable` trống | No hoặc Yes | No  | Tạo ra ngoại lệ `ValueError` |
| `iterable` trống | Yes | Yes  | Trả về giá trị `default` |
| `iterable` trống | Yes | Yes  | Trả về giá trị `default` |
| 1 `iterable` (không trống) | No | Yes hoặc No |  Trả về số lớn nhất trong `iterable` |
| 1 `iterable` (không trống) | Yes | Yes hoặc No |  Chuyển mỗi phần tử trong hàm có thể lặp lại đến hàm chính và Trả về phần tử lớn nhất dựa trên giá trị trả về của hàm chính |
| Nhiều `iterable` (không trống) | No | Yes hoặc No | Trả về lớn nhất trong số các vòng lặp đã cho |
| Nhiều `iterable` (không trống) | No | Yes hoặc No | Chuyển mỗi lần lặp lại đến hàm chính Trả về giá trị lặp lớn nhất dựa trên giá trị trả về của hàm chính |

Giá trị trả về đối với `max(arg1, arg2, *args[, key])`:

| Trường hợp | Key | Giá trị trả về |
|-------------|----------------|-----------|
| Đã thực hiện 2 đối số đầu tiên | No | Trả về lớn nhất trong số các đối số đã cho |
| Đã thực hiện 2 đối số đầu tiên | Yes | Chuyển các đối số đến hàm chính Trả về lớn nhất trong số các đối số dựa trên giá trị trả về của hàm chính |
| Đã thực hiện nhiều hơn 2 đối số | No | Trả về lớn nhất trong số các đối số đã cho |
| Đã thực hiện nhiều hơn 2 đối số | Yes | Vượt qua từng phép tính đến hàm chính Trả về lớn nhất trong số các đối số dựa trên giá trị trả về của hàm chính |

Ví dụ : Tìm số lớn nhất trong số các số đã cho
```py
# sử dụng max(arg1, arg2, *args)
print(max(1, 3, 2, 5, 4))
5
# sử dụng max(iterable)
num = [1, 3, 2, 8, 5, 10, 6]
print(max(num))
10
```
Tìm số có tổng số chữ số lớn nhất bằng cách sử dụng hàm chính:
```py
def sumDigit(num):
    sum = 0
    while(num):
        sum += num % 10
        num = int(num / 10)
    return sum
# sử dụng max(arg1, arg2, *args, key)
print('Số lớn nhất là:', max(100, 321, 267, 59, 40, key=sumDigit))
267
# sử dụng max(iterable, key)
num = [15, 300, 2700, 821, 52, 10, 6]
print('Số lớn nhất là:', max(num, key=sumDigit))
821
```
Tìm danh sách có độ dài tối đa bằng cách sử dụng hàm từ khóa
```py
num = [15, 300, 2700, 821]
num1 = [12, 2]
num2 = [34, 567, 78]
# Sử dụng max(iterable, *iterables, key)
print(max(num, num1, num2, key=len))
[15, 300, 2700, 821]
```
#### memoryview(obj)
Hàm trả về một đối tượng xem bộ nhớ của đối số đã cho. Hàm nhận 1 tham số duy nhất là các đối tượng có dữ liệu nội bộ được hiển thị và obj phải hỗ trợ giao thức đêm (`byte`, `bytearray`)
** Giao thức đệm là gì?
Nói một cách đơn giản, giao thức đệm cung cấp cách truy cập dữ liệu nội bộ của một đối tượng. Dữ liệu bên trong này là mảng bộ nhớ hoặc bộ đệm.
Giao thức đệm cho phép một đối tượng để lộ dữ liệu bên trong của nó (bộ đệm) và một đối tượng khác để truy cập các bộ đệm đó mà không cần sao chép trung gian.
Giao thức này chỉ cho chúng ta truy cập ở cấp C-API và không thể sử dụng cơ sở mã thông thường của chúng ta.
** Chế độ xem bộ nhớ là gì?
Giao diện bộ nhớ là một cách an toàn để mở ra cho chúng ta xem giao thức đệm trong Python. Nó cho phép bạn truy cập các bộ đệm bên trong của một đối tượng bằng cách tạo một đối tượng xem bộ nhớ.
** Tại sao giao thức đệm và khung nhìn bộ nhớ lại quan trọng?
Chúng ta cần phải nhớ rằng bất cứ khi nào chúng ta thực hiện một số hành động trên một đối tượng (gọi một hàm của một đối tượng, cắt một mảng), chúng ta (hoặc Python) cần phải tạo một bản sao của đối tượng .
Nếu chúng ta có một dữ liệu lớn để làm việc với (ví dụ dữ liệu nhị phân của một hình ảnh), chúng ta sẽ tạo ra các bản sao dữ liệu khổng lồ không cần thiết, hầu như không sử dụng.
Sử dụng giao thức đệm, chúng ta có thể cung cấp cho một đối tượng truy cập để sử dụng/sửa đổi dữ liệu lớn mà không cần sao chép nó. Điều này làm cho chương trình sử dụng ít bộ nhớ hơn và tăng tốc độ thực thi.
```py
randomByteArray = bytearray('ABC', 'utf-8')
mv = memoryview(randomByteArray)
# chỉ số index của chế độ xem bộ nhớ truy cập
print(mv[0])
65
# tạo byte từ khung nhìn bộ nhớ
print(bytes(mv[0:2]))
b'AB'
# tạo list từ khung nhìn bộ nhớ
print(list(mv[0:3]))
[65, 66, 67]
```
Ở đây, chúng ta tạo một đối tượng khung nhìn bộ nhớ `mv` từ mảng byte `randomByteArray`. Sau đó, chúng a truy cập chỉ mục thứ `0` của `mv` giá trị `'A'` và in nó (cung cấp giá trị ASCII - 65).
Một lần nữa, chúng ta truy cập các chỉ số của `mv` từ `0` và `1` với giá trị thu được (`'AB'`) và chuyển chúng thành các `byte`.
Cuối cùng, chúng ta đã truy cập tất cả các chỉ mục của `mv` và chuyển đổi nó thành `list`. Kể từ khi, bên trong `bytearray` lưu trữ giá trị ASCII cho các bảng chữ cái, đầu ra là một danh sách các giá trị ASCII của A, B và C.

Sửa đổi dữ liệu nội bộ bằng cách sử dụng chế độ xem bộ nhớ:
```py
randomByteArray = bytearray('ABC', 'utf-8')
print(randomByteArray)
bytearray(b'ABC')
mv = memoryview(randomByteArray)
# Chỉnh sửa index thứ nhất của mv sang Z
mv[1] = 90
print(randomByteArray)
bytearray(b'AZC')
```
Ở đây, chúng tôi đã cập nhật chỉ mục thứ nhất của chế độ xem bộ nhớ thành `ASCII` (`90 (Z)`).Bở vì, đối tượng xem bộ nhớ mv tham chiếu cùng bộ đệm/bộ nhớ, việc cập nhật chỉ mục trong `mv` cũng cập nhật `randomByteArray` .


#### min()
```py
min(iterable, *iterables[,key, default])
min(arg1, arg2, *args[, key])
```
Hàm trả về phần tử nhỏ nhất trong một tham số có thể lặp lại hoặc nhỏ nhất của hai hoặc nhiều tham số
Cách xây dựng giống với [max()](https://iamfinn.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-41).

#### next(iterator, default)
Hàm trả về mục tiếp theo từ trình lặp với `iterator` là trình lặp, `default` là giá trị được trả về nếu vòng lặp đã hết (không có mục nào còn lại). Nếu tham số `default` không được thiết lập, khi `iterator` kết  thúc, nó sẽ tạo ra ngoại lệ `StopIteration`.
```py
random = [5, 9, 'cat']
# chuyển đổi list thành iterator
randomIterator = iter(random)
print(randomIterator)
5
print(next(randomIterator))
9
print(next(randomIterator))
'cat'
print(next(randomIterator))
StopIteration
```
Với trường hợp sử dụng `default`:
```py
random = [5, 9]

# chuyển đổi list thành iterator
randomIterator = iter(random)
5
print(next(randomIterator, '-1'))
9
print(next(randomIterator, '-1'))
-1
print(next(randomIterator, '-1'))
-1
print(next(randomIterator, '-1'))
-1
```

#### o = object()
Điều này trả về một đối tượng đặc biệt là một cơ sở cho tất cả các lớp. Hàm không chấp nhận bất kỳ tham số nào và trả về một đối tượng đặc biệt.
```py
test = object()
print(type(test))
#<class 'object'>
print(dir(test))
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
```
Ở đây, một đối tượng thử nghiệm của class `Object` được tạo ra. chúng ta sử dụng các hàm dựng sẵn `type()` và `dir()` để lấy kiểu và tất cả các thuộc tính của đối tượng tương ứng.
Đối tượng không có `__dict__` được đề xuất bởi đầu ra. Do đó, bạn không thể gán các thuộc tính tùy ý cho các cá thể của lớp này.

#### oct(x)
lấy một số nguyên (nhị phân, thập phân hoặc thập lục phân) và trả về biểu diễn bát phân của nó. Nếu không phải là số nguyên, phải thực hiện phương thức `__index__()` để trả về một số nguyên.
```py
>>> oct(10)
0o12
>>> oct(0b101)
0o5
```
Sử dụng cho đối tượng tùy chọn thực hiện `__index()__`
```py
class Person:
    age = 23
    def __index__(self):
        return self.age
    def __int__(self):
        return self.age
person = Person()
print(oct(person))
0o27
```

#### open(file, mode='r', [buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None])
Hàm mở tệp (nếu có thể) có thể được sử dụng để đọc, ghi và sửa đổi tệp và trả về một đối tượng tệp tương ứng. Nếu không tìm thấy tệp, nó sẽ tạo râ ngoại lệ `FileNotFoundError`.
Các tham số:
+ `file`: đường dẫn giống như đối tượng (đại diện cho một đường dẫn hệ thống tập tin).
+ `mode:` chế độ khi mở tệp. Nếu không được cung cấp, nó sẽ mặc định `r` (mở để đọc ở chế độ văn bản). Các chế độ tệp khả dụng là:

| Chế độ | Miêu tả |
|-----------|----------|
| `'r'` | Mở tệp để đọc (mặc định) |
| `'w'` | Mở một tập tin để viết. Tạo một tệp mới nếu nó không tồn tại hoặc cắt bớt tệp nếu nó tồn tại. |
| `'x'` | Mở một tệp để tạo. Nếu tệp đã tồn tại, thao tác không thành công. |
| `'a'` | Mở để thêm vào cuối tệp mà không cắt xén nó. Tạo một tệp mới nếu nó không tồn tại. |
| `'t'` | Mở ở chế độ văn bản. (mặc định) |
| `'b'` | Mở ở chế độ nhị phân. |
| `'+'` | Mở một tệp để cập nhật (đọc và viết) |

+ `buffering`: được sử dụng để đặt chính sách đệm
+ `encoding`: tên mã hóa để mã hóa hoặc giải mã tệp
+ `errors`: chuỗi chỉ định cách xử lý lỗi mã hóa/giải mã
+ `newline`: làm thế nào với chế độ dòng mới (giá trị có sẵn: None, ' ', '\n', 'r', và'\r\n'
+ `closefd` : phải là True(mặc định) nếu được đưa ra, nếu không thì một ngoại lệ sẽ được nâng lên
+ `opener`: một công cụ mở tùy chỉnh; phải trả về một bộ mô tả tập tin mở
```py
# mở file test.text ở cùng một thư mục
f = open("test.txt")
# chỉ rõ đường dẫn và chế đố mở
f = open("C:/Python37/README.txt", mode='r')
```

#### ord(c)
Hàm trả về một số nguyên đại diện cho điểm mã Unicode cho ký tự Unicode đã cho. Là hàm nghịch đảo của [chr()](https://iamfinn.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-10).
```py
print(ord('5'))
53 
print(ord('A'))
65
print(ord('$'))
36
```

#### pow(x, y[, z])
Hàm tương đương với:
```py
x**y
```
Hàm trả về giá trị `x lũy thừa y`. Nếu đối số thứ ba (`z`) được đưa ra, nó trả giá trị phép chia lấy phần dư giữa `x lũy thừa y` và `z`, tức là `pow(x, y)%z`. 
Với trường hợp `y` là số nguyên âm thì `z` không nên được thiết lập.
```py
print(pow(2, 2))
4
print(pow(-2, 2))
4
print(pow(2, -2))
0.25
print(pow(-2, -2))
0.25
print(pow(7, 2, 5))
4
```

#### print(`*objects`, sep=' ', end='\n', file=sys.stdout, flush=False)
Hàm in đối tượng đã cho tới thiết bị đầu ra tiêu chuẩn (màn hình) hoặc tệp luồng văn bản và không trả về bất kỳ giá trị nào; trả về `None` 
Các tham số:
+ `objects`: đối tượng được in. `*` cho biết rằng có thể có nhiều hơn một đối tượng
+ `sep`: các đối tượng được phân cách bằng sep. Giá trị mặc định :`' '`
+ `end`: kí tự cuối được in tại cuối cùng
+ `file`: phải là một đối tượng với phương thức `write(string)`. Nếu bỏ qua nó, `sys.stdout` sẽ được sử dụng để in các đối tượng trên màn hình.
+ `flush`: Nếu `True`, luồng sẽ bị dội ngược. Giá trị mặc định : `False`
```py
>>> a = 5
>>> print("a = ", a, sep='00000', end='\n')
'a = 000005'
>>> print("a = ", a, sep='0', end='')
'a = 05'
```

#### property(fget=None, fset=None, fdel=None, doc=None)
Hàm trả về thuộc tính property từ getter, setter và deleter đã cho. Hàm nhận bốn tham số tùy chọn:
+ `fget`: chức năng nhận giá trị thuộc tính
+ `fset`: chức năng để thiết lập giá trị thuộc tính
+ `fdel`: chức năng xóa giá trị thuộc tính
+ `doc`: chuỗi chứa tài liệu (`docstring`) cho thuộc tính
Nếu không có đối số nào được đưa ra, hàm `property()` trả về thuộc tính thuộc tính cơ sở không chứa bất kỳ `getter`, `setter` hoặc `deleter` nào và nếu `doc` không được cung cấp, phương thức `property()` lấy `docstring` của hàm `getter`.
Ví dụ, tạo thuộc tính với `getter`, `setter`, `deleter` sử dụng `property()`
```py
class Person:
    def __init__(self, name):
        self._name = name

    def getName(self):
        print('Tên bắt đầu')
        return self._name

    def setName(self, value):
        print('Đặt tên thành ' + value)
        self._name = value

    def delName(self):
        print('Xóa tên')
        del self._name
    name = property(getName, setName, delName, 'Thuộc tính name')

p = Person('Adam')
print(p.name)
p.name = 'John'
del p.name
# Output
Tên bắt đầu
Adam
Đặt tên thành John
Xóa tên
```
Ở đây, `_name` được sử dụng như biến riêng để lưu trữ tên của một `Person`.
Các phương thức ta đã sử dụng ở trên:
+ một phương thức getter `getName()` để lấy tên của người đó,
+ một phương thức setter `setName()` để đặt tên của người đó,
+ một phương pháp deleter `delName()` để xóa tên của người đó.
Bây giờ, chúng ta đặt tên thuộc tính thuộc tính mới bằng cách gọi hàm `property()`. Như được hiển thị trong chương trình, tham chiếu `p.name` nội bộ gọi `getName()` như getter, `setName()` như setter và `delName()` như deleter thông qua đầu ra in hiện tại bên trong các phương thức. `Docstring` của thuộc tính thành `Thuộc tính name`.
Ví dụ 2, tạo thuộc tính với `getter`, `setter`, `deleter` sử dụng `@property()` decorator:
```py
class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Tên bắt đầu')
        return self._name

    @name.setter
    def name(self, value):
        print('Đặt tên thành ' + value)
        self._name = value

    @name.deleter
    def name(self):
        print('Xóa tên')
        del self._name
p = Person('Adam')
print('Tên là:', p.name)
p.name = 'John'
del p.name
# Output
Tên bắt đầu
Tên là: Adam
Đặt tên thành John
Xóa tên
```
Ở đây, thay vì sử dụng phương thức `property()`, chúng ta đã sử dụng hàm decorator `@property`.
Đầu tiên, chúng ta chỉ rõ phương thức `name()` đó cũng là một thuộc tính của`Person`. Điều này được thực hiện bằng cách sử dụng `@property` trước phương thức `getter` như được hiển thị trong chương trình.
Tiếp theo, chúng ta sử dụng tên thuộc tính để chỉ định `setter` và `deleter`. Điều này được thực hiện bằng cách sử dụng `@<name-of-attribute>.setter(@name.setter)` cho phương thức setter và `@<name-of-attribute>.deleter(@name.deleter)` cho phương thức deleter.
Lưu ý, chúng ta đã sử dụng cùng một phương pháp `name()` với các định nghĩa khác nhau để xác định `getter`, `setter` và `deleter`.
Bây giờ, bất cứ khi nào chúng ta sử dụng `p.name`, nó gọi nội bộ `getter`, `setter` và `deleter` thích hợp như được hiển thị bởi đầu ra in hiện diện bên trong phương thức.

#### range()
```py
range(stop)
range(start, stop[, step])
```
Hàm trả về một chuỗi các số không thay đổi giữa số nguyên bắt đầu đã cho với số nguyên dừng.Với 3 tham số:
+ `start`: số nguyên bắt đầu từ đó chuỗi số nguyên được trả về
+ `end`: số nguyên trước khi chuỗi số nguyên được trả về. 
+ `step`: giá trị số nguyên xác định tăng giữa mỗi số nguyên trong chuỗi
Hàm sẽ trả về dãy `sequence` của các số bắt đầu từ `0` đến `stop -1` và trả về một dãy `sequence` trống nếu `stop` là số âm hoặc bằng `0`.
Giá trị trả về được tính theo công thức sau với các ràng buộc đã cho
```
r[n] = start + step * n (cho cả step dương và âm) 
trong đó: n >= 0 và r [n] < stop (đối với step dương) 
trong đó: n> = 0 và r [n]> stop ( cho step âm)
```
Nếu `step` không được thiết lập:  thì `step` mặc định là `1`. Trả về một dãy số bắt đầu `start` và kết thúc tại `stop - 1`.
Nếu `step` bằng `0`: Tạo ra một ngoại lệ `ValueError`
Nếu `step` khác `0`: Kiểm tra nếu ràng buộc giá trị được đáp ứng và trả về một chuỗi theo công thức .
Còn lại, Nếu nó không đáp ứng ràng buộc giá trị, chuỗi rỗng được trả về.
```py
>>> print(list(range(1, 10)))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print(list(range(2, 14, 2)))
[2, 4, 6, 8, 10, 12]
>>> print(list(range(2, -14, -2)))
[2, 0, -2, -4, -6, -8, -10, -12]
>>> print(list(range(2, 14, -2)))
[]
```

#### repr(obj)
Hàm trả về một biểu diễn có thể in của đối tượng đã cho. Nó trả về một chuỗi có thể sinh ra một đối tượng có cùng giá trị khi được chuyển tới `eval()`.
`eval(repr(obj)) = obj (xấp xỉ đúng đối với hầu hết các kiểu tích hợp sẵn của Python)`
```py
var = 'foo'
repr(var)
"'foo'"
class Person:
    name = 'Adam'

    def __repr__(self):
        return repr(self.name)

repr(Person())
"'Adam'"
```
Phương thức repr() trả về `"'foo'"`, `'foo'` bên trong dấu ngoặc kép. Điều quan trọng là `'foo'` là một chuỗi nên nó được biểu diễn bằng dấu nháy đơn. `'foo'` không có dấu ngoặc kép sẽ gán biến var cho foo .
Điều này là quan trọng bởi vì, `repr()` trả về một chuỗi có cùng giá trị được chuyển tới `eval()`.
Nếu chúng ta phải chuyển 'foo' thành chuỗi `eval()` làm chuỗi, nó sẽ được truyền trong dấu ngoặc kép để thoát khỏi dấu nháy đơn nội bộ, `eval("'foo'")` giống như đầu ra của `repr()`.

#### reversed(seq)
Hàm trả về `iterator` đảo ngược của chuỗi đã cho. `seq` là chuỗi cần đảo ngược hoặc một đối tượng hỗ trợ giao thức chuỗi (`__len()__` và `__getitem()__`) như `tuple`, `string`, `list`, `range` hoặc cũng có thể là một đối tượng đã thực hiện `__reversed__()`.
```py
list(reversed('Python'))
['n', 'o', 'h', 't', 'y', 'P']
# Hoặc đối tượng hỗ trợ
class Vowels:
    vowels = ['a', 'e', 'i', 'o', 'u']

    def __reversed__(self):
        return reversed(self.vowels)
v = Vowels()
print(list(reversed(v)))
['u', 'o', 'i', 'e', 'a']
```
#### round(number[, ndigits])
Hàm trả về số `float` được làm tròn thành các chữ số thập phân đã cho sau dấu thập phân. Nếu không có `ndigits` được cung cấp, nó sẽ làm tròn số tới số nguyên gần nhất.
```py
# đối với số nguyên
print(round(10))
10
# đối với số thập phân
print(round(10.7))
11
# lựa chọn ngẫu nhiên
print(round(5.5))
6
print(round(2.665, 2))
2.67
print(round(2.675, 2))
2.67
```

#### set([iterable])
Hàm xây dựng một `set` Python từ vòng lặp đã cho và trả về nó.
```py
# set rỗng
print(set())
set()
# từ string
print(set('Python'))
{'P', 'o', 't', 'n', 'y', 'h'}
# từ tuple
print(set(('a', 'e', 'i', 'o', 'u')))
{'a', 'o', 'e', 'u', 'i'}
# từ list
print(set(['a', 'e', 'i', 'o', 'u']))
{'a', 'o', 'e', 'u', 'i'}
# từ hàm range
print(set(range(5)))
{0, 1, 2, 3, 4}
```
Ví dụ hàm `set` đối với tập các `set` `dict` và `frozenset`:
```py
print(set({'a', 'e', 'i', 'o', 'u'}))
{'a', 'o', 'i', 'e', 'u'}
print(set({'a':1, 'e': 2, 'i':3, 'o':4, 'u':5}))
{'a', 'o', 'i', 'e', 'u'}
frozenSet = frozenset(('a', 'e', 'i', 'o', 'u'))
print(set(frozenSet))
{'a', 'o', 'e', 'u', 'i'}
```
Đối với đối tượng `iterable` :
```py
class PrintNumber:
    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.num = 0
        return self

    def __next__(self):
        if(self.num >= self.max):
            raise StopIteration
        self.num += 1
        return self.num

printNum = PrintNumber(5)

print(set(printNum))
{1, 2, 3, 4, 5}
```

#### setattr(object, name, value)
Hàm lấy một thuộc tính của một đối tượng.
Hàm nhận ba tham số:
+ `object`: đối tượng có thuộc tính phải được đặt
+ `name`: string chứa tên của thuộc tính được đặt
+ `value`: giá trị của thuộc tính được đặt
```py
class Person:
    name = 'Adam'
    
p = Person()
print('Before modification:', p.name)
Before modification: Adam

# setting name to 'John'
setattr(p, 'name', 'John')

print('After modification:', p.name)
After modification: John
```

#### Slice()
```
slice(stop)
slice(start, stop, step)
```
Hàm được sử dụng để cắt một chuỗi nhất định ( string, byte, tuple, list hoặc range) hoặc bất kỳ đối tượng nào hỗ trợ giao thức `sequence`(thực hiện phương thức `__getitem__ ()` và `__len __ ()`). Và trả về một đối tượng slice được sử dụng để cắt một chuỗi trong các chỉ mục đã cho.
Hàm có 3 tham số:
+ `start`: bắt đầu số nguyên nơi việc cắt của đối tượng bắt đầu
+ `stop`: số nguyên cho đến khi việc cắt lát diễn ra. Việc cắt dừng tại điểm dừng chỉ số - 1 .
+ `step`: xác định mức tăng giữa mỗi chỉ mục để cắt
Nếu một tham số đơn được truyền, thì `start` và `step` được đặt thành `0`.
```py
>>> print(slice(3))
slice(None, 3, None)
>>> print(slice(1, 5, 2))
slice(1, 5, 2)
```
Ví dụ 2, Nhận chuỗi con từ một chuỗi đã cho bằng cách sử dụng đối tượng slice
```py
>>> pyString = 'Python'
>>> sObject = slice(3)
>>> print(pyString[sObject])
pyt
>>> sObject = slice(1, 5, 2)
>>> print(pyString[sObject])
yh
# Với chỉ mục âm
>>> pyString = 'Python'
>>> sObject = slice(-1, -4, -1)
>>> print(pyString[sObject])
noh
```
Ví dụ 3, Nhận danh sách và tuple con từ danh sách và tuple đã cho tương ứng:
```py
>>> pyList = ['P', 'y', 't', 'h', 'o', 'n']
>>> pyTuple = ('P', 'y', 't', 'h', 'o', 'n')
>>> sObject = slice(3)
>>> print(pyList[sObject])
['P', 'y', 't']
>>> sObject = slice(1, 5, 2)
>>> print(pyTuple[sObject])
('y', 'h')
# Với chỉ số âm
>>> pyList = ['P', 'y', 't', 'h', 'o', 'n']
>>> pyTuple = ('P', 'y', 't', 'h', 'o', 'n')
>>> sObject = slice(-1, -4, -1)
>>> print(pyList[sObject])
['n', 'o', 'h']
>>> sObject = slice(-1, -5, -2)
>>> print(pyTuple[sObject])
('n', 'h')
```

#### sorted(iterable[, key][, reverse])
Hàm trả về một danh sách được sắp xếp từ vòng lặp đã cho.
Hàm nhận 3 tham số:
+ `iterable`: thường là dãy `sequence` ( string, tuple, list ) hoặc `collection` (set, dictionary, frozen set) hoặc bất kỳ trình lặp nào 
+ `reverse`:  Nếu đúng, danh sách được sắp xếp được đảo ngược (hoặc được sắp xếp theo thứ tự Giảm dần)
+ `key`: chức năng đóng vai trò như một khóa cho so sánh sắp xếp
```py
>>> pyList = ['e', 'a', 'u', 'o', 'i']
>>> print(sorted(pyList))
['a', 'e', 'i', 'o', 'u']
>>> pyString = 'Python'
>>> print(sorted(pyString))
['P', 'h', 'n', 'o', 't', 'y']
>>> pyTuple = ('e', 'a', 'u', 'o', 'i')
>>> print(sorted(pyTuple))
['a', 'e', 'i', 'o', 'u']
```
Lưu ý: `list` cũng có phương thức `sort()` thực hiện theo cách tương tự như được `sort()`. Chỉ có sự khác biệt, phương thức `sort()` không trả về bất kỳ giá trị nào và thay đổi chính danh sách gốc.
Ví dụ 2, sắp xếp một `collection` đã cho theo thứ tự giảm dần: `set`, `dictionary` and `frozen set`:
```py
# set
>>> pySet = {'e', 'a', 'u', 'o', 'i'}
>>> print(sorted(pySet, reverse=True))
['u', 'o', 'i', 'e', 'a']
# dictionary
>>> pyDict = {'e': 1, 'a': 2, 'u': 3, 'o': 4, 'i': 5}
>>> print(sorted(pyDict, reverse=True))
['u', 'o', 'i', 'e', 'a']
# frozen set
>>> pyFSet = frozenset(('e', 'a', 'u', 'o', 'i'))
>>> print(sorted(pyFSet, reverse=True))
['u', 'o', 'i', 'e', 'a']
```
Ví dụ 3, sắp xếp danh sách bằng cách sử dụng `key` là một hàm:
```py
def takeSecond(elem):
    return elem[1]

random = [(2, 2), (3, 4), (4, 1), (1, 3)]
sortedList = sorted(random, key=takeSecond)
print('Sorted list:', sortedList)
[(4, 1), (2, 2), (1, 3), (3, 4)]
```

#### staticmethod(function)
Hàm trả về một `static method` cho hàm đã cho. Ta có thể sủ dụng `decorator` cho hàm này. Ví dụ:
```py
@staticmethod
def func(args, ...)
```
Các `static method`, giống như các [classmethod](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-11) , là các phương thức được liên kết với một lớp chứ không phải đối tượng của nó.
Chúng không yêu cầu tạo một cá thể lớp. Vì vậy, không phụ thuộc vào trạng thái của đối tượng. Sự khác biệt giữa một phương thức tĩnh và một phương thức lớp là:
+ `static method` không biết gì về lớp và chỉ giao dịch với các tham số.
+ `class method` làm việc với lớp vì tham số của nó luôn là lớp.
Chúng có thể được gọi bởi cả lớp và đối tượng của nó.
```py
Class.staticmethodFunc()
# Hoặc
Class().staticmethodFunc()
```
Ví dụ:
```py
class Mathematics:

    def addNumbers(x, y):
        return x + y

Mathematics.addNumbers = staticmethod(Mathematics.addNumbers)
print(Mathematics.addNumbers(5, 10))
15
```
* Vậy khi nào chúng ta dùng `static method`
** Nhóm các hàm tiện ích cho một class. 
Các phương thức tĩnh được sử dụng rất hạn chế, bởi vì giống như các `class method` hoặc bất kỳ phương thức nào khác trong một lớp, chúng không thể truy cập các thuộc tính của chính lớp đó.
Tuy nhiên, khi bạn cần một hàm tiện ích không truy cập bất kỳ thuộc tính nào của một lớp nhưng có ý nghĩa rằng nó thuộc về lớp, chúng ta sử dụng các `static method`.
```py
class Dates:
    def __init__(self, date):
        self.date = date
        
    def getDate(self):
        return self.date

    @staticmethod
    def toDashDate(date):
        return date.replace("/", "-")

date = Dates("15-12-2016")
dateFromDB = "15/12/2016"
dateWithDash = Dates.toDashDate(dateFromDB)

if(date.getDate() == dateWithDash):
    print("Bằng nhau")
else:
    print("Không bằng nhau")
Bằng nhau
```
Giải thích:
Ở đây, chúng ta có một lớp `Dates` chỉ nhận các ngày có dấu gạch ngang. Tuy nhiên, trong cơ sở dữ liệu của chúng ta, tất cả các ngày đều có mặt trong dấu gạch chéo.
Để chuyển đổi các dấu gạch chéo ngày thành dấu gạch ngang, chúng tôi đã tạo ra một hàm tiện ích `toDashDate` bên trong `Dates`.
Nó là một phương thức tĩnh bởi vì nó không cần truy cập bất kỳ thuộc tính nào của chính các ngày đó và chỉ yêu cầu các tham số.
Chúng ta cũng có thể tạo ra `toDashDate` bên ngoài lớp nhưng vì nó chỉ hoạt động cho các ngày, nên hợp lý nhất là để nó bên trong lớp `Dates`.
** Có một triển khai đơn lẻ
Các phương thức tĩnh được sử dụng khi chúng ta không muốn các class con có một sự thay đổi/ghi đè một phương thức cụ thể.
```py
class Dates:
    def __init__(self, date):
        self.date = date
        
    def getDate(self):
        return self.date

    @staticmethod
    def toDashDate(date):
        return date.replace("/", "-")

class DatesWithSlashes(Dates):
    def getDate(self):
        return Dates.toDashDate(self.date)

date = Dates("15-12-2016")
dateFromDB = DatesWithSlashes("15/12/2016")
if(date.getDate() == dateFromDB.getDate()):
    print("Bằng nhau")
else:
    print("Không bằng nhau")
Bằng nhau
```
Giải thích:
Ở đây, chúng ta sẽ không muốn lớp con `DatesWithSlashes` ghi đè lên hàm `toDashDate` vì nó chỉ có một lần sử dụng duy nhất, tức là ngày thay đổi thành các dấu gạch ngang.
Chúng ta có thể dễ dàng sử dụng `static method`  ghi đè hàm `getDate()` trong lớp con sao cho nó hoạt động tốt với lớp `DatesWithSlashes`.

#### str()
trả về biểu diễn "không chính thức" hoặc có thể in độc đáo của một đối tượng đã cho. Cú pháp của hàm biểu diễn như sau:
```py
str(object='')
str(object=b'', encoding='utf-8', errors='strict')
```
Hàm `str()` chủ yếu lấy ba tham số giống nhau cho cả hai cấu trúc:
+ `object`: đối tượng có biểu diễn không chính thức sẽ được trả về
+ `encoding`: Mặc định của UTF-8. Mã hóa của đối tượng đã cho
+ `errors`:  phản hồi khi giải mã không thành công. 
Có sáu loại phản hồi lỗi như sau:
+ `strict`: mặc định tạo ra ngoại lệ `UnicodeDecodeError` khi xảy ra lỗi
+ `ignore`: bỏ qua chuỗi unicode không thể giải mã được từ kết quả
+ `replace`: thay thế unicode không thể giải mã thành một dấu chấm hỏi `?`
+ `xmlcharrefreplace`: chèn tham chiếu ký tự `XML` thay vì unicode không thể giải mã được
+ `backslashreplace`: chèn một chuỗi kí tự thoát `\uNNNN` espace thay vì unicode không thể giải mã được
+ `namereplace`: chèn một chuỗi kí tự thoát `\N {...}` thay vì unicode không thể giải mã được
```py
>>> str('10')
'10'
# bytes
>>> b = bytes('pythön', encoding='utf-8')
>>> print(str(b, encoding='ascii', errors='ignore'))
pythn
```

#### sum(iterable, start)
Hàm có chức năng thêm các mục của một `iterable` và trả về tổng của chúng.
Hàm nhận 2 tham số:
+ `iterable`: có thể là(list, tuple, dict ...vv). Thông thường, các mục của iterable phải là số.
+ `start`: giá trị này được thêm vào tổng của các mục có thể lặp lại. Giá trị mặc định của khởi động là 0 (nếu bỏ qua)
```py
>>> numbers = [2.5, 3, 4, -5]
# start không được cung cấp
>>> numbersSum = sum(numbers)
>>> print(numbersSum)
4.5
# start = 10
>>> umbersSum = sum(numbers, 10)
>>> print(numbersSum)
10
```
Nếu bạn cần thêm số float với độ chính xác thập phân, bạn nên sử dụng `math.fsum(iterable)` thay vì sử dujgn `sum()`
Nếu bạn cần ghép các mục của vòng lặp đã cho (các mục phải là chuỗi), thì bạn có thể sử dụng phương thức `join()`.
```py
'' .join (sequence)
```

#### super()
Hàm trả về một đối tượng `được cấp phép` cho phép bạn tham chiếu lớp cha bằng `super`.
Trong Python, `super()` được xây dựng trong có hai trường hợp sử dụng chính:
+ Cho phép chúng ta tránh sử dụng lớp cơ sở một cách rõ ràng.
+ Làm việc với nhiều thừa kế.
Ví dụ 1, `super()` với 1 thừa kế
```py
class Mammal(object):
  def __init__(self, mammalName):
    print(mammalName, 'Chó là một động vật máu nóng')
    
class Dog(Mammal):
  def __init__(self):
    print('Chó có bốn chân. ')
    super().__init__('Dog')
    
d1 = Dog()
Chó có bốn chân. 
Chó là một động vật máu nóng
```
Ở đây, chúng ta gọi phương thức `__init__` của lớp `Mammal` (từ lớp `Dog`) bằng cách sử dụng mã:
```py
super () .__ init __ ('Dog')
```
thay vì
```py
Mammal.__init__(self, 'Dog')
```
Vì chúng ta không cần phải chỉ định tên của lớp cơ sở nếu chúng ta sử dụng `super()`, chúng ta có thể dễ dàng thay đổi lớp cơ sở cho phương thức `Dog` một cách dễ dàng (nếu cần).
```py
class Dog(CanidaeFamily):
  def __init__(self):
    print('Chó có 4 chân.')

    # không cần phải thay đổi điều này
    super().__init__('Dog')
```
Ví dụ 2: `super()` với đa thừa kế.
```py
class Animal:
  def __init__(self, animalName):
    print(animalName, 'là một con vật.');

class Mammal(Animal):
  def __init__(self, mammalName):
    print(mammalName, 'là một động vật máu nóng.')
    super().__init__(mammalName)
    
class NonWingedMammal(Mammal):
  def __init__(self, NonWingedMammalName):
    print(NonWingedMammalName, "không thể bay.")
    super().__init__(NonWingedMammalName)

class NonMarineMammal(Mammal):
  def __init__(self, NonMarineMammalName):
    print(NonMarineMammalName, "không thể bơi.")
    super().__init__(NonMarineMammalName)

class Dog(NonMarineMammal, NonWingedMammal):
  def __init__(self):
    print('Chó có 4 chân.');
    super().__init__('Dog')
    
d = Dog()
print('')
bat = NonMarineMammal('Bat')
Chó có 4 chân. 
Chó không thể bơi. 
Chó không thể bay. 
Chó là một động vật máu nóng. 
Chó là một con vật. 

Bat không biết bơi. 
Bat là một động vật máu nóng. 
Bat là một con vật.
```
Thứ tự độ ưu tiên của phuwong thức (MRO)
Đó là thứ tự mà phương thức nên được kế thừa trong sự hiện diện của nhiều thừa kế. Bạn có thể xem MRO bằng cách sử dụng thuộc tính `__mro__`.
```
>>> Dog .__ mro__ 
(<class 'Dog'>, 
<class 'NonMarineMammal'>, 
<class 'NonWingedMammal'>, 
<class 'Động vật có vú'>, 
<class 'Animal'>, 
<class 'object'>)
```
Đây là cách MRO được tính bằng Python:
+ Một phương thức trong các cuộc gọi có nguồn gốc luôn được gọi trước phương thức của lớp cơ sở. 
+ Trong ví dụ của chúng ta, lớp` Dog` được gọi trước `NonMarineMammal` hoặc `NoneWingedMammal`. Hai lớp này được gọi trước khi `Mammal` và `Animal` được gọi , và lớp `Animal` được gọi trước `object` .
Nếu có nhiều lớp cha thích `Dog(NonMarineMammal, NonWingedMammal)`, phương thức `NonMarineMammal` được gọi trước tiên bởi vì nó xuất hiện đầu tiên.

#### tuple(iterable)
Hàm được sử dụng để tạo ra một bộ `tuple` bằng Python.
```py
t1 = tuple()
print(t1)
()
# tạo tuple từ list
t2 = tuple([1, 4, 6])
print(t2)
(1, 4, 6)
# tạo tuple từ string
t1 = tuple('Python')
print(t1)
('P', 'y', 't', 'h', 'o', 'n')
# tạo tuple từ dictionary
t1 = tuple({1: 'one', 2: 'two'})
print(t1)
(1, 2)
```

#### type()
Cú pháp của hàm:
```py
type(object)
type(name, bases, dict)
```
Nếu một đối số (`object`) được truyền vào `type()`, nó trả về kiểu của đối tượng đã cho. Nếu ba đối số (`name`, `bases`, `dict)` được truyền vào, nó trả về một đối tượng kiểu mới.
```py
numberList = [1, 2]
print(type(numberList))
#<class 'dict'>
numberDict = {1: 'one', 2: 'two'}
print(type(numberDict))
class Foo:
    a = 0

InstanceOfFoo = Foo()
print(type(InstanceOfFoo))
#<class 'Foo'>
```
Nếu bạn cần kiểm tra kiểu của một đối tượng, bạn nên sử dụng hàm Python `isinstance()` để thay thế. Đó là bởi vì hàm `isinstance()`cũng kiểm tra nếu đối tượng đã cho có phải là một thể hiện của lớp con.
Hàm `type(name, bases, dict)` nhận 3 tham số là:
+ `name`: tên lớp trở thành thuộc tính `__name__`.
+ `bases`: một `tuple` phân loại class cơ sở, trở thành thuộc tính `__bases__`.
+ `dict`: một từ điển là không gian tên chứa các định nghĩa cho thân lớp; trở thành thuộc tính `__dict__`.
```py
o1 = type('X', (object,), dict(a='Foo', b=12))
print(type(o1))
#<class 'type'>
print(vars(o1))
{'b': 12, 'a': 'Foo', '__dict__': <attribute '__dict__' of 'X' objects>, '__doc__': None, '__weakref__': <attribute '__weakref__' of 'X' objects>}
class test:
  a = 'Foo'
  b = 12
  
o2 = type('Y', (test,), dict(a='Foo', b=12))
print(type(o2))
#<class 'type'>
print(vars(o2))
{'b': 12, 'a': 'Foo', '__doc__': None}
```
Trong chương trình, chúng ta đã sử dụng hàm Python [vars()](https://0xpan.blogspot.com/2018/11/danh-sach-cac-ham-dung-san-python.html#load-h4-66) trả về thuộc tính `__dict__`.` __dict__` được sử dụng để lưu trữ các thuộc tính ghi của đối tượng.
Bạn có thể dễ dàng thay đổi các thuộc tính này nếu cần. Ví dụ, nếu bạn cần thay đổi thuộc tính  `__name__` của `o1` thành `Z`, chỉ cần sử dụng:
```py
o1 .__ name = 'Z'
```

#### vars(object)
Hàm trả về thuộc tính `__dict__` của đối tượng đã cho nếu đối tượng có thuộc tính `__dict__`. Nếu đối tượng được truyền đến `vars()` không có thuộc tính `__dict__`, nó sẽ tạo ra một ngoại lệ `TypeError`.
Nếu không có đối số nào được truyền cho `vars()`, hàm này hoạt động như hàm `locals()`.
```py
class Foo:
  def __init__(self, a = 5, b = 10):
    self.a = a
    self.b = b
  
InstanceOfFoo = Foo()
print(vars(InstanceOfFoo))
{'a': 5, 'b': 10}
```
Bạn cũng có thể sử dụng các lệnh sau ở Python Shell:
```py
vars(list)
vars(str)
vars(dict) 
```

#### zip(`*iterables`)
Hàm `zip()` nhận một `iterable` (có thể bằng 0 hoặc nhiều hơn), làm cho `iterator` tổng hợp các phần tử dựa trên các vòng lặp được truyền và trả về một trình lặp của các `tuple`
Hàm zip được diễn giải bằng code như sau:
```py
def zip(*iterables):
    # zip('ABCD', 'xy') --> Ax By
    sentinel = object()
    iterators = [iter(it) for it in iterables]
    while iterators:
        result = []
        for it in iterators:
            elem = next(it, sentinel)
            if elem is sentinel:
                return
            result.append(elem)
        yield tuple(result)
```
Hàm `zip()` trả về một bộ lặp của các bộ dữ liệu dựa trên đối tượng `iterable`:
+ Nếu không có tham số nào được truyền, hàm `zip()` trả về một `iterator` trống.
+ Nếu một `iterable` được chuyển qua, hàm `zip()` trả về một trình lặp của 1-tuple. Có nghĩa là, số phần tử trong mỗi bộ là 1.
+ Nếu có nhiều `iterable`, `tuple` thứ `i` chứa giả định thứ `i`, hai vòng lặp được truyền; một `iterable` có chứa `3` và có chứa `5`phần tử khác. Sau đó, trình lặp trở lại có 3 bộ dữ liệu. Đó là bởi vì `iterator` dừng lại khi lặp lại ngắn nhất là điều không được cao sách cho lắm..
```py
numberList = [1, 2, 3]
strList = ['one', 'two', 'three']

# không có iterables được truyền vào
result = zip()

# chuyển đổi itertor thành list
resultList = list(result)
print(resultList)
[]
# 2 iterables được truyền
result = zip(numberList, strList)

# Chuyển đổi itertor thành set
resultSet = set(result)
print(resultSet)
{(2, 'two'), (3, 'three'), (1, 'one')}
```
Ví dụ 2, Các số khác nhau của các phần tử thuộc `iterables` được chuyển vào `zip()`
```py
numbersList = [1, 2, 3]
strList = ['one', 'two']
numbersTuple = ('ONE', 'TWO', 'THREE', 'FOUR')
result = zip(numbersList, numbersTuple)
# chuyển đổi thành set
resultSet = set(result)
print(resultSet)
{(2, 'TWO'), (3, 'THREE'), (1, 'ONE')}
result = zip(numbersList, strList, numbersTuple)
# chuyển đổi thành set
resultSet = set(result)
print(resultSet)
{(2, 'two', 'TWO'), (1, 'one', 'ONE')}
```
Ví dụ 3, giải nén giá trị sử dụng `zip()`
```py
coordinate = ['x', 'y', 'z']
value = [3, 4, 5, 0, 9]
result = zip(coordinate, value)
resultList = list(result)
print(resultList)
[('x', 3), ('y', 4), ('z', 5)]
c, v =  zip(*resultList)
print('c =', c)
c = ('x', 'y', 'z')
print('v =', v)
v = (3, 4, 5)
```
Lưu ý rằng, các phần tử `0` và `9` trong giá trị biến không nằm trong biến `v`. Đó là vì các `iterables` được nén có số lượng phần tử khác nhau.

#### __import__(name, globals=None, locals=None, fromlist=(), level=0)
là một hàm nâng cao được gọi bởi câu lệnh import.
hàm nhận các tham số:
+ `name`: tên của mô-đun bạn muốn nhập
+ `globals` và `locals`: xác định cách thông dịch `name`
+ `fromlist`: đối tượng hoặc mô-đun con phải được nhập theo tên
+ `level`: xác định liệu có sử dụng nhập khẩu tuyệt đối hay tương đối hay không
Hàm `__import __ ()` này không cần thiết trong lập trình Python hàng ngày. Nó hiếm khi được sử dụng và thường không khuyến khích.
Hàm này có thể được sử dụng để thay đổi ngữ nghĩa của câu lệnh nhập như `import`. Tuy nhiên, tốt hơn hết là sử dụng `import`.
Nếu bạn muốn nhập mô-đun theo tên, hãy sử dụng [importlib.import_module()](https://docs.python.org/3/library/importlib.html#importlib.import_module) để thay thế.
```py
mathematics = __import__('math', globals(), locals(), [], 0)
print(mathematics.fabs(-2.5))
2.5
```
Nói chung, `fabs()` là một phương thức được định nghĩa trong mô-đun `math`. Bạn có thể gọi hàm này bằng cú pháp sau:
```py
math.fabs (x)
```
Tuy nhiên, việc sử dụng `__import__() `đã thay đổi cách truy cập `fabs()` trong chương trình trên.


